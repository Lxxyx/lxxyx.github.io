<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>寒假前端学习(6)——学习JavaScript数据结构与算法（四）：二叉搜索树 | Lxxyx的前端乐园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本系列的第一篇文章: 学习JavaScript数据结构与算法（一）：栈与队列第二篇文章：学习JavaScript数据结构与算法（二）：链表第三篇文章: 学习JavaScript数据结构与算法（三）：集合第四篇文章: 学习JavaScript数据结构与算法（四）：二叉搜索树

我与二叉树的前尘往事在刚学编程时，就知道有一种数据结构叫“树”，树中的翘楚是“二叉树”，“红黑树”等。据说“树”构在编程界">
<meta property="og:type" content="article">
<meta property="og:title" content="寒假前端学习(6)——学习JavaScript数据结构与算法（四）：二叉搜索树">
<meta property="og:url" content="http://www.lxxyx.win/2016/01/19/寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树/index.html">
<meta property="og:site_name" content="Lxxyx的前端乐园">
<meta property="og:description" content="本系列的第一篇文章: 学习JavaScript数据结构与算法（一）：栈与队列第二篇文章：学习JavaScript数据结构与算法（二）：链表第三篇文章: 学习JavaScript数据结构与算法（三）：集合第四篇文章: 学习JavaScript数据结构与算法（四）：二叉搜索树

我与二叉树的前尘往事在刚学编程时，就知道有一种数据结构叫“树”，树中的翘楚是“二叉树”，“红黑树”等。据说“树”构在编程界">
<meta property="og:image" content="http://7xoxxe.com1.z0.glb.clouddn.com/tree1.png">
<meta property="og:image" content="http://7xoxxe.com1.z0.glb.clouddn.com/tree.png">
<meta property="og:image" content="http://7xoxxe.com1.z0.glb.clouddn.com/tree.png">
<meta property="og:updated_time" content="2016-05-27T10:45:31.637Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="寒假前端学习(6)——学习JavaScript数据结构与算法（四）：二叉搜索树">
<meta name="twitter:description" content="本系列的第一篇文章: 学习JavaScript数据结构与算法（一）：栈与队列第二篇文章：学习JavaScript数据结构与算法（二）：链表第三篇文章: 学习JavaScript数据结构与算法（三）：集合第四篇文章: 学习JavaScript数据结构与算法（四）：二叉搜索树

我与二叉树的前尘往事在刚学编程时，就知道有一种数据结构叫“树”，树中的翘楚是“二叉树”，“红黑树”等。据说“树”构在编程界">
<meta name="twitter:image" content="http://7xoxxe.com1.z0.glb.clouddn.com/tree1.png">
  
    <link rel="alternative" href="/atom.xml" title="Lxxyx的前端乐园" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xk109.com1.z0.glb.clouddn.com/blog-head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Lxxyx</a></h1>
		</hgroup>

		
		<p class="header-subtitle">文科生の前端生活</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/前端">前端之路</a></li>
				        
							<li><a href="/tags/管理">管理学习</a></li>
				        
							<li><a href="/tags/随笔">随笔杂文</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Lxxyx" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Lxxyx" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:Lxxyxzj@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/管理/" style="font-size: 10px;">管理</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://guowenfh.github.io/">三省吾身丶丶</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zhibinnet.com/">island的个人网站</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ienning.com/">Enning</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">某211的纯文科生，2018年毕业。热爱前端与Node.js。在学校的网站工作室中担任前端开发的工作，有实际项目经验。将来想成为一名前端工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Lxxyx</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xk109.com1.z0.glb.clouddn.com/blog-head.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Lxxyx</h1>
			</hgroup>
			
			<p class="header-subtitle">文科生の前端生活</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/前端">前端之路</a></li>
		        
					<li><a href="/tags/管理">管理学习</a></li>
		        
					<li><a href="/tags/随笔">随笔杂文</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Lxxyx" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Lxxyx" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:Lxxyxzj@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/19/寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树/" class="article-date">
  	<time datetime="2016-01-19T09:58:57.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      寒假前端学习(6)——学习JavaScript数据结构与算法（四）：二叉搜索树
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本系列的第一篇文章: <a href="http://t.cn/R4Ybrs0" target="_blank" rel="external">学习JavaScript数据结构与算法（一）：栈与队列</a><br>第二篇文章：<a href="http://t.cn/R4W3y3X" target="_blank" rel="external">学习JavaScript数据结构与算法（二）：链表</a><br>第三篇文章: <a href="http://t.cn/R4jLf0o" target="_blank" rel="external">学习JavaScript数据结构与算法（三）：集合</a><br>第四篇文章: <a href="http://t.cn/R4QbVOg" target="_blank" rel="external">学习JavaScript数据结构与算法（四）：二叉搜索树</a></p>
</blockquote>
<h2 id="我与二叉树的前尘往事"><a href="#我与二叉树的前尘往事" class="headerlink" title="我与二叉树的前尘往事"></a>我与二叉树的前尘往事</h2><p>在刚学编程时，就知道有一种数据结构叫“树”，树中的翘楚是“二叉树”，“红黑树”等。<br>据说“树”构在编程界呼风唤雨无所不能。让无数程序员闻风丧胆。甚至在面试时，更是有“手写二叉树”，“翻转二叉树”等题目坐镇。</p>
<p>好吧，我承认这些在当时都把我吓住了。</p>
<p>但是当我颤抖着打开《学习JavaScript数据结构与算法》，开始敲下关于“树”的代码时，突然觉得，好像也没有那么难呢。<br>于是心怀激动，一口气敲完了书上的例子，中途也思考了很久，不断的在纸上演算等。但总的来说，还是学的很开心的。</p>
<h2 id="树の简介"><a href="#树の简介" class="headerlink" title="树の简介"></a>树の简介</h2><p>之前学的栈、队列、链表等数据结构，都是顺序数据结构。而树，将会是我们学的第一种非顺序数据结构。</p>
<p>放在现实里呢，有个很生动的例子，公司组织架构图。长这样:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/tree1.png" alt="公司组织架构图"></p>
<p>而我们要学的树，长这样:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/tree.png" alt="树の图示"></p>
<h3 id="节点简介"><a href="#节点简介" class="headerlink" title="节点简介"></a>节点简介</h3><p>其中，树中的每个元素，都叫做<code>节点</code>。从节点延伸而下的，叫<code>子节点</code>。<br>树顶部的节点叫根节点。每棵树只有一个根节点。（图中15就是根节点）<br>在节点中，有子节点的节点也称为内部节点，没有的话则被称为外部节点或者叶节点。<br>同时在节点中是有祖先和后代关系的，比如节点9的祖先就有13,7,6,15四个。</p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>深度: 节点的深度取决于其祖先的数量，节点9的深度就是4。<br>树的高度，树的高度体现为节点深度的最大值。<br>比如上图，节点深度最大值为4，则树的高度为4。</p>
<h3 id="二叉树与二叉搜索树"><a href="#二叉树与二叉搜索树" class="headerlink" title="二叉树与二叉搜索树"></a>二叉树与二叉搜索树</h3><p>二叉树的最大特点就在于，它的节点最多只有两个子节点:左侧子节点和右侧子节点。<br>二叉搜索树则是二叉树的一种，但它只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。<br>像刚才的这幅图，就是二叉搜索树。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/tree.png" alt="二叉搜索树"></p>
<p>而我们本文要学习的内容，就是如何写一个二叉搜索树。</p>
<h3 id="JavaScipt中二叉搜索树的实现"><a href="#JavaScipt中二叉搜索树的实现" class="headerlink" title="JavaScipt中二叉搜索树的实现"></a>JavaScipt中二叉搜索树的实现</h3><p>首先，创建一个构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 二叉搜索树的构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 二叉搜索树键的构造函数</span><br><span class="line">   * @param &#123;Number&#125; key 要生成的键值</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 键值</span></span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 二叉树的根节点，不存在时表示为Null</span><br><span class="line">   * @type &#123;Null or Number&#125;</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在之前提到过的双向链表中，每个节点包含两个指针，一个指向左侧节点，一个指向右侧节点。在二叉搜索树中，每个节点也有两个指针，一个指向左侧子节点，一个指向右侧子节点。但在二叉搜索树中，我们把节点成为<code>键</code>，这是术语。</p>
<p>二叉搜索树需要有如下的方法:</p>
<ul>
<li>insert(key): 向树中插入一个新的键</li>
<li>inOrderTraverse(): 通过中序遍历方式，遍历所有节点</li>
<li>preOrderTranverse(): 通过先序遍历方式，遍历所有节点</li>
<li>postOrderTranverse(): 通过后序遍历方式，遍历所有节点</li>
<li>min(): 返回树中最小的值</li>
<li>max(): 返回树中最大的值</li>
<li>search(key): 搜索某个值，在树中则返回true</li>
<li>remove(key): 从树中移除某个键</li>
</ul>
<p>二叉搜索树的实现，基本都与递归有关（对我来说递归很绕，花了很久才理解）。如果不清楚递归相关概念，可以看看下面的参考链接。</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/20507130" target="_blank" rel="external">什么是递归</a></p>
</blockquote>
<h4 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法:"></a>insert方法:</h4><p>说明:向树中插入一个新的键<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入某个键到二叉树中</span><br><span class="line"> * @param  &#123;Number&#125; key 要插入的键值</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用传入的值生成二叉树的键</span></span><br><span class="line">  <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根节点为Null时，传入的键则为根节点</span></span><br><span class="line">  <span class="comment">// 否则调用insertNode函数来插入子节点</span></span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    root = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    insertNode(root, newNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 用于插入子节点。</span><br><span class="line"> * @param  &#123;Node&#125; node    根节点</span><br><span class="line"> * @param  &#123;Node&#125; newNode 要插入的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//由于二叉搜索树的性质，所以当键值小于当前所在节点的键值</span></span><br><span class="line">  <span class="comment">//则使得左子结点成为新的要比较的节点，进行递归调用</span></span><br><span class="line">  <span class="comment">//如果左子结点为null，则将键值赋值给左子结点。</span></span><br><span class="line">  <span class="comment">//如果键值大于当前所在节点的键值，原理同上。</span></span><br><span class="line">  <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      insertNode(node.left, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.right = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      insertNode(node.right, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="inOrderTraverse方法"><a href="#inOrderTraverse方法" class="headerlink" title="inOrderTraverse方法:"></a>inOrderTraverse方法:</h4><p>说明:通过中序遍历方式，遍历所有节点<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 中序遍历操作，常用于排序。会把树中元素从小到大的打印出来。</span><br><span class="line"> * 因为在javascript的递归中，遇到递归是，会优先调用递归的函数。直到递归不再进行。</span><br><span class="line"> * 然后会在递归调用的最后一个函数中执行其它语句。再一层层的升上去。</span><br><span class="line"> * 所以中序遍历会有从小到大的输出结果。</span><br><span class="line"> * 后续的先序和后续遍历和这个原理差不多，取决于callback放在哪儿。</span><br><span class="line"> * </span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  inOrderTraverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 中序遍历的辅助函数，用于遍历节点</span><br><span class="line"> * @param  &#123;Node&#125;   node     遍历开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> * @return &#123;[type]&#125;            [description]</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前节点不为NULL则继续递归调用</span></span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    inOrderTraverseNode(node.left, callback);</span><br><span class="line">    <span class="comment">// 获取到节点后，调用的函数</span></span><br><span class="line">    callback(node.key);</span><br><span class="line">    inOrderTraverseNode(node.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>假如我们这儿加入打印节点值的函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNode = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inOrderTraverse(printNode) <span class="comment">// 输出排序后树的值</span></span><br></pre></td></tr></table></figure></p>
<h4 id="preOrderTranverse方法"><a href="#preOrderTranverse方法" class="headerlink" title="preOrderTranverse方法:"></a>preOrderTranverse方法:</h4><p>说明:通过先序遍历方式，遍历所有节点<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 前序遍历操作，常用于打印一个结构化的文档</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.preOrderTranverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  preOrderTranverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 前序遍历的辅助函数，用于遍历节点</span><br><span class="line"> * @param  &#123;Node&#125;   node     遍历开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> preOrderTranverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    callback(node.key);</span><br><span class="line">    preOrderTranverseNode(node.left, callback);</span><br><span class="line">    preOrderTranverseNode(node.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="postOrderTranverse方法"><a href="#postOrderTranverse方法" class="headerlink" title="postOrderTranverse方法:"></a>postOrderTranverse方法:</h4><p>说明:通过后序遍历方式，遍历所有节点<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 后序遍历操作，常用于计算所占空间</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.postOrderTranverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  postOrderTranverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 后序遍历的辅助函数，用于遍历节点</span><br><span class="line"> * @param  &#123;Node&#125;   node     遍历开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> postOrderTranverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  postOrderTranverseNode(node.left, callback);</span><br><span class="line">  postOrderTranverseNode(node.right, callback);</span><br><span class="line">  callback(node.key);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="min方法"><a href="#min方法" class="headerlink" title="min方法:"></a>min方法:</h4><p>说明:返回树中最小的值，由二叉搜索树的性质易知，最左侧的为最小值。则只需取得最左侧的值即可。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回树中最小的值</span><br><span class="line"> * @return &#123;Function&#125; min函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> minNode(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * min函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 查找开始的节点，默认为root</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果node存在，则开始搜索。能避免树的根节点为Null的情况</span></span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。</span></span><br><span class="line">    <span class="comment">// 若左子节点为null，则该节点肯定为最小值。</span></span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="max方法"><a href="#max方法" class="headerlink" title="max方法:"></a>max方法:</h4><p>说明:返回树中最大的值，由min函数易知，最大值在最右侧。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回树中最大的值</span><br><span class="line"> * @return &#123;Function&#125; max函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> maxNode(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * max函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 查找开始的节点，默认为root</span><br><span class="line"> * @return &#123;Key&#125;      节点的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="search方法"><a href="#search方法" class="headerlink" title="search方法:"></a>search方法:</h4><p>说明: 搜索某个值，在树中则返回true<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 搜索某个值是否存在于树中</span><br><span class="line"> * @param  &#123;Node&#125; key 搜索开始的节点，默认为root</span><br><span class="line"> * @return &#123;Function&#125;     search函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> searchNode(root, key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * search函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 搜索开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Key&#125; key  要搜索的键值</span><br><span class="line"> * @return &#123;Boolean&#125;      找到节点则返回true，否则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果根节点不存在，则直接返回null</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">    searchNode(node.left, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">    searchNode(node.right, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果该节点值等于传入的值，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法:"></a>remove方法:</h4><p>说明:从树中移除某个键，要应对的场景:</p>
<ol>
<li>只是一个叶节点</li>
<li>有一个子节点</li>
<li>有两个子节点的节点<br>因为要应付不同的场景，所以这是最麻烦的方法了。让我思考了好久才理解。如果你觉得看不懂的话，可以下载源代码把这一段写一遍。<br>实现: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 从树中移除某个键</span><br><span class="line"> * @param  &#123;Key&#125; key 要移除的键值</span><br><span class="line"> * @return &#123;Function&#125;     remove函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  root = removeNode(root, key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * remove函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 搜索开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Key&#125; key   要移除的键值</span><br><span class="line"> * @return &#123;Boolean&#125;   移除成功则返回true，否则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果根节点不存在，则直接返回null</span></span><br><span class="line">  <span class="keyword">if</span> (node === root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未找到节点前，继续递归调用。</span></span><br><span class="line">  <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">    node.left = removeNode(node.left, key)</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">    node.right = removeNode(node.right, key)</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一种场景：只是一个叶节点</span></span><br><span class="line">    <span class="comment">// 这种情况只需要直接把节点赋值为null即可</span></span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 处理完直接return节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二种场景：有一个子节点</span></span><br><span class="line">    <span class="comment">// 如果左节点为null，则代表右节点存在。</span></span><br><span class="line">    <span class="comment">// 于是把当前节点赋值为存在的那个子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">      <span class="comment">// 处理完直接return节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">      <span class="comment">// 处理完直接return节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第三种场景：有两个子节点</span></span><br><span class="line">    <span class="comment">// 首先加入辅助节点，同时找寻右子节点中的最小节点</span></span><br><span class="line">    <span class="comment">// 并把当前节点替换为右子节点中的最小节点</span></span><br><span class="line">    <span class="comment">// 同时为了避免节点重复，移除右子节点中的最小节点</span></span><br><span class="line">    <span class="keyword">var</span> aux = findMinNode(node.right);</span><br><span class="line">    node.key = aux.key;</span><br><span class="line"></span><br><span class="line">    node.right = removeNode(node.right, aux.key);</span><br><span class="line">    <span class="comment">// 处理完直接return节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * remove函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 查找开始的节点，默认为root</span><br><span class="line"> * @return &#123;Node&#125;      最小的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果node存在，则开始搜索。能避免树的根节点为Null的情况</span></span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。</span></span><br><span class="line">    <span class="comment">// 若左子节点为null，则该节点肯定为最小值。</span></span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码:"></a>源代码:</h4><p>源代码在此~</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/BinarySearchTree.js" target="_blank" rel="external">二叉搜索树-源代码</a></p>
</blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>写文章的时候，人有点感冒，晕晕乎乎的。不过写完之后就好多了，脑子清醒了许多。<br>二叉树这一章，就我而言感慨万分，也算是暂时满足了自己对数据结构中“树”的向往与愿望，也不是之前看数据结构中那种迷茫的感觉。<br>能用JavaScript亲手实现，还是非常开心的。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/01/27/迁移至Ubuntu的折腾之旅/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          迁移至Ubuntu的折腾之旅
        
      </div>
    </a>
  
  
    <a href="/2016/01/16/寒假前端学习/寒假前端学习(5)——学习JavaScript数据结构与算法：集合/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">寒假前端学习(5)——学习JavaScript数据结构与算法（三）：集合</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树" data-title="寒假前端学习(6)——学习JavaScript数据结构与算法（四）：二叉搜索树" data-url="http://www.lxxyx.win/2016/01/19/寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"Lxxyx"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Lxxyx
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71744638-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




  </div>
</body>
</html>