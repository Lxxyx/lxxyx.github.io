<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Lxxyx的前端乐园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文科生，热爱前端与Node.js。2018年毕业">
<meta property="og:type" content="website">
<meta property="og:title" content="Lxxyx的前端乐园">
<meta property="og:url" content="http://www.lxxyx.win/index.html">
<meta property="og:site_name" content="Lxxyx的前端乐园">
<meta property="og:description" content="文科生，热爱前端与Node.js。2018年毕业">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lxxyx的前端乐园">
<meta name="twitter:description" content="文科生，热爱前端与Node.js。2018年毕业">
  
    <link rel="alternative" href="/atom.xml" title="Lxxyx的前端乐园" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xk109.com1.z0.glb.clouddn.com/blog-head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Lxxyx</a></h1>
		</hgroup>

		
		<p class="header-subtitle">文科生の前端生活</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/前端">前端之路</a></li>
				        
							<li><a href="/tags/管理">管理学习</a></li>
				        
							<li><a href="/tags/随笔">随笔杂文</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Lxxyx" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Lxxyx" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:Lxxyxzj@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/管理/" style="font-size: 10px;">管理</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://guowenfh.github.io/">三省吾身丶丶</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zhibinnet.com/">island的个人网站</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ienning.com/">Enning</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">某211的纯文科生，2018年毕业。热爱前端与Node.js。在学校的网站工作室中担任前端开发的工作，有实际项目经验。将来想成为一名前端工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Lxxyx</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xk109.com1.z0.glb.clouddn.com/blog-head.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Lxxyx</h1>
			</hgroup>
			
			<p class="header-subtitle">文科生の前端生活</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/前端">前端之路</a></li>
		        
					<li><a href="/tags/管理">管理学习</a></li>
		        
					<li><a href="/tags/随笔">随笔杂文</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Lxxyx" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Lxxyx" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:Lxxyxzj@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-备战期末考试，暑期再见" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/21/备战期末考试，暑期再见/" class="article-date">
  	<time datetime="2016-05-21T08:52:28.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/21/备战期末考试，暑期再见/">备战期末考试，暑期再见~</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>距离宣布更新博客已经两个月了，一共写了6篇博客。<br>然后就进入考试月，得准备期末考试的复习了。<br>至于写博客，说实话，可写的话题越来越窄。基础知识大抵了解，中高级知识了解不多。处于很尴尬的位置。</p>
<h2 id="暑期"><a href="#暑期" class="headerlink" title="暑期"></a>暑期</h2><p>博客预计恢复更新的时间，应该在暑期。那时候时间多，且自己暑期会去北京闪银奇异实习，能学习到大量的前端知识，相信对于我是一个很大的提高。<br>那时候再来更新，相信对自己和对各位都会有帮助，而非单纯的凑凑字数啥的。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>就酱~</p>
<blockquote>
<p>山不在高，有仙则灵。<br>水不在深，有龙则灵。<br>文不在多，有助则灵。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-深入理解JavaScript类数组" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/07/深入理解JavaScript类数组/" class="article-date">
  	<time datetime="2016-05-07T02:28:49.000Z" itemprop="datePublished">2016-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/07/深入理解JavaScript类数组/">深入理解JavaScript类数组</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>写这篇博客的起因，是我在知乎上回答一个问题时，说自己在学前端时把《JavaScript高级程序设计》看了好几遍。<br>于是在评论区中，出现了如下的对话：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/array3.png" alt="对话"></p>
<p>天啦噜，这话说的，宝宝感觉到的，是满满的恶意啊。还好自己的JavaScript基础还算不错，没被打脸。（吐槽一句：知乎少部分人真的是恶意度爆表，整天想着打别人的脸。都是搞技术的，和善一点不行吗…………）</p>
<p>不过这个话题也引起了我的注意，问了问身边很多前端同学关于数组与类数组的区别。他们都表示不太熟悉，所以决定写一篇博客，来分享我对数组与类数组的理解。</p>
<h2 id="什么是类数组"><a href="#什么是类数组" class="headerlink" title="什么是类数组"></a>什么是类数组</h2><p>类数组的定义，只有一条：<br>  有length属性。</p>
<p>这儿有三个典型的JavaScript类数组例子。</p>
<ol>
<li>DOM方法:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有div</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arrayLike))  <span class="comment">// [object NodeList]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike.length) <span class="comment">// 127</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrayLike[<span class="number">0</span>]) </span><br><span class="line"><span class="comment">// &lt;div id="js-pjax-loader-bar" class="pjax-loader-bar"&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arrayLike)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">arrayLike.push(<span class="string">'push'</span>) </span><br><span class="line"><span class="comment">// Uncaught TypeError: arrayLike.push is not a function(…)</span></span><br></pre></td></tr></table></figure>
<p>是的，这个arrayLike的 <code>NodeList</code>，有length，也能用数组下标访问，但是使用Array.isArray测试时，却告诉我们它不是数组。直接使用push方法时，当然也会报错。<br>但是，我们可以借用类数组方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">arr.push(<span class="string">'push something to arr'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr[arr.length - <span class="number">1</span>]) <span class="comment">// push something to arr</span></span><br></pre></td></tr></table></figure>
<p>不难看出，此时的arrayLike在调用数组原型方法时，返回值已经转化成数组了。也能正常使用数组的方法。</p>
<ol>
<li>类数组对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLikeObj = &#123;</span><br><span class="line">  length: <span class="number">2</span>,</span><br><span class="line">  <span class="number">0</span>: <span class="string">'This is Array Like Object'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObj.length) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeObj[<span class="number">0</span>]) <span class="comment">// This is Array Like Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arrayLikeObj)) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrObj = <span class="built_in">Array</span>.prototype.slice.call(arrayLikeObj, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arrObj)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个例子也很好理解。一个对象，加入了length属性，再用Array的原型方法处理一下，摇身一变成为了真的数组。</p>
<ol>
<li>类数组函数</li>
</ol>
<p>这个应该算是最好玩，也是最迷惑人的类数组对象了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLikeFunc1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeFunc1.length) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> arrFunc1 = <span class="built_in">Array</span>.prototype.slice.call(arrayLikeFunc1, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arrFunc1, arrFunc1.length) <span class="comment">// ([], 0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLikeFunc2 = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arrayLikeFunc2.length) <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> arrFunc2 = <span class="built_in">Array</span>.prototype.slice.call(arrayLikeFunc2, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arrFunc2, arrFunc2.length) <span class="comment">// ([undefined × 2], 2)</span></span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>函数也有length属性，其值等于函数要接收的参数。</strong></p>
<blockquote>
<p>注：不适用于ES6的rest参数。具体原因和表现这儿就不再阐述了，不属于本文讨论范围。可参见 <a href="http://es6.ruanyifeng.com/#docs/function#rest参数" target="_blank" rel="external">《rest参数 - ECMAScript 6 入门》</a>。另外arguments在ES6中，被rest参数代替了，所以这儿不作为例子。</p>
</blockquote>
<p>而length属性大于0时，如果转为数组，则数组里的值会是undefined。个数等于函数length的长度。</p>
<h2 id="类数组的实现原理"><a href="#类数组的实现原理" class="headerlink" title="类数组的实现原理"></a>类数组的实现原理</h2><p>类数组的实现原理，主要有以下两点：<br>第一点是JavaScript的“万物皆对象”概念。<br>第二点则是JavaScript支持的“鸭子类型”。</p>
<p>首先，从第一点开始解释。</p>
<h3 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h3><p>万物皆对象具体解释如下：</p>
<blockquote>
<p>在JavaScript中，“一切皆对象”，数组和函数本质上都是对象，就连三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p>
</blockquote>
<p>而另外一个要点则是，所有对象都继承于Object。所以都能调用对象的方法，比如使用点和方括号访问属性。<br>比如说，这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line">func[<span class="number">0</span>] = <span class="string">'I\'m a func'</span></span><br><span class="line"><span class="built_in">console</span>.log(func[<span class="number">0</span>]) <span class="comment">// 'I\'m a func'</span></span><br></pre></td></tr></table></figure>
<h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>万物皆对象具体解释如下：</p>
<blockquote>
<p>如果它走起来像鸭子，而且叫起来像鸭子，那么它就是鸭子。</p>
</blockquote>
<p>比如说上面举的类数组例子，虽然他们是对象/函数，但是只要有length属性，能当数组用，那么他们就是数组。<br>是什么，不是什么对鸭子类型来说，一点也不重要。能做什么，才是鸭子类型的核心。（谢谢nightre大大的指正）</p>
<p>但是，在这儿，还是有些迷糊的。为什么使用<code>call/apply</code>借用数组方法就能处理这些类数组呢？</p>
<h2 id="探秘V8"><a href="#探秘V8" class="headerlink" title="探秘V8"></a>探秘V8</h2><p>一开始，我也对这个犯迷糊啊。直到我去Github上，看到了谷歌V8引擎处理数组的源代码。<br>地址在这儿：<a href="https://github.com/v8/v8/blob/master/src/js/array.js" target="_blank" rel="external">v8/array.js</a><br>作为讲述，我们在这里引用push的源代码（方便讲述，删除部分。slice的比较长，但是原理一致）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appends the arguments to the end of the array and returns the new</span></span><br><span class="line"><span class="comment">// length of the array. See ECMA-262, section 15.4.4.7.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取要处理的数组</span></span><br><span class="line">  <span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 获取数组长度</span></span><br><span class="line">  <span class="keyword">var</span> n = TO_LENGTH(array.length);</span><br><span class="line">  <span class="comment">// 获取函数参数长度</span></span><br><span class="line">  <span class="keyword">var</span> m = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="comment">// 将函数参数push进数组</span></span><br><span class="line">    array[i+n] = <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修正数组长度</span></span><br><span class="line">  <span class="keyword">var</span> new_length = n + m;</span><br><span class="line">  array.length = new_length;</span><br><span class="line">  <span class="comment">// 返回值是数组的长度</span></span><br><span class="line">  <span class="keyword">return</span> new_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的，<strong>整个push函数，并没有涉及是否是数组的问题。只关心了length。而因为其对象的特性，所以可以使用方括号来设置属性。</strong></p>
<p>这也是万物皆类型和鸭子类型最生动的体现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript中的类数组的特殊性，是由其“万物皆类型”和“鸭子类型”决定的，而浏览器引擎底层的实现，更是佐证了这一点。<br>而先前说我的那位同学，因为只是知道类数组的几种表现和用法，并且想通过apply来打我脸，证明我根本没有仔细看书。这种行为不仅不友善，而且学习效率也不高。<br>因为，<strong>知其然而不知其所以然是不可取的</strong>。特别是发现很多这种例子，就得学会归纳总结。（感谢winter老师的演讲：<a href="http://taobaofed.org/blog/2016/03/23/the-growth-of-front-end/" target="_blank" rel="external">一个前端的自我修养</a>，教会我很多东西。）。<br>很多时候，深入看看源代码也会让你对这个理解的更透彻。将来就算是蹦出一百种类数组，也能知道是怎么回事儿。</p>
<p>最后，还是开头那句话：“都是搞技术的，和善一点不行吗？有问题就好好交流，不要总想着打别人脸啊…………”</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Always-bet-on-f2e" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/01/Always-bet-on-f2e/" class="article-date">
  	<time datetime="2016-05-01T01:12:31.000Z" itemprop="datePublished">2016-05-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/01/Always-bet-on-f2e/">Always bet on F2E</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这篇文章应该五一就发出来的，但是写到一半，和室友出去浪了。还剩下最后一点，在五月七号给补完了。</p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>学习编程和前端的路上，有过欢笑有过迷茫。<br>庆幸的是，我从15年3月份开始学编程，到15年10月份确定以编程作为我大学的方向，只花了6个月。因为编程使我感到快乐。<br>更庆幸的是，我从15年10月份到16年5月份，花了7个月。确定把前端作为编程的方向。因为这能让我的优势得到最大的发挥，而且，我喜欢前端啊。</p>
<h2 id="我所理解的前端"><a href="#我所理解的前端" class="headerlink" title="我所理解的前端"></a>我所理解的前端</h2><p>昨天和一位前端的前辈聊天，他看了看我的博客，和我说：“你只要坚持下去，毕业之后一定会在前端有所建树的。”<br>当然，他指的前端可能是HTML,CSS,JavaScript。跑在浏览器的前端，基于JavaScript的前端。但是，不是我所理解的前端。</p>
<p>我所理解的前端，正如维基百科给出的定义一般：</p>
<blockquote>
<p>在软件架构和程序设计领域，前端是软件系统中直接和用户交互的部分。</p>
</blockquote>
<p>也正如我现在干的事情一般，一半时间写Node.js，一半时间写前端。</p>
<h2 id="没有常青树"><a href="#没有常青树" class="headerlink" title="没有常青树"></a>没有常青树</h2><p>作为一名公共管理学院的文科生，阅读过许多历史学与管理学的书籍。对这些书籍的理解，就有一条：<strong>“没有常青树”</strong>。<br>在软件开发的领域，时局瞬息万变。树立起没有常青树的概念是很重要的，君且看万古时空，多少王朝沉浮。也看硅谷，曾经的王者雅虎，如今也不得挂牌出售。</p>
<p>因为没有常青树，所以不愿把自己局限于仅仅只是跑在浏览器的前端，基于JavaScript的前端。<br>所以我更加认同：<strong>“前端是软件系统中直接和用户交互的部分”</strong>。</p>
<p>虽然目前JavaScript是王者地位，自己也很喜欢它。但WebAssembly的出现，VR/AR的发展，总有一天，情势会变化的。<br>无论那一天依然是JavaScript登顶，或者是别的替代了它。</p>
<p>我都喜欢做前端啊，直接与用户交互的，决定用户体验好坏的前端，需要懂得计算机基础，也要理解设计、交互、产品、后台知识的前端啊。</p>
<h2 id="Always-bet-on-F2E"><a href="#Always-bet-on-F2E" class="headerlink" title="Always bet on F2E"></a>Always bet on F2E</h2><p>曾经看过一个slides，最后有这么一些话：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/bet.png" alt="Always bet on js"><br>这些话是Brendan Eich，也就是JavaScript之父说的。</p>
<p>这也是我想说的话：Always bet on F2E.<br>可能有人会说，这样会不会太过偏激，知识面狭窄？</p>
<p>我喜欢编程，因为写代码就是一件很开心的事情。只是更加偏向于前端。<br>于是我决定了，这就是我编程学习的方向，不再迷茫Java好还是C#的语法优雅又或是XXX的发展前途广。<br>因为有用户交互的地方，就有前端。而语言只是其实现方式而已。</p>
<p><strong>So,always bet on F2E</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-从零组装新工具 - Koa2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/23/从零组装新工具 - Koa2/" class="article-date">
  	<time datetime="2016-04-23T12:27:06.000Z" itemprop="datePublished">2016-04-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/23/从零组装新工具 - Koa2/">从零组装新工具 - Koa2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>整个项目已开源于Github，项目地址：<a href="https://github.com/Lxxyx/koa2-easy" target="_blank" rel="external">koa2-easy</a>，<a href="http://koa.ncuhr.win" target="_blank" rel="external">在线Demo:</a></p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>作为一个前端，Node.js算是必备知识之一。同时因为自己需要做一些后台性的工作，或者完成一个小型应用。所以学习了Node的Express框架，用于辅助和加速开发。</p>
<p>不过当初自己对Express的学习和了解，并不是很深入。要求也仅仅是停留在能发送静态文件，构建后台API，与数据库完成简单交互而已。所以当初自己选用Express时，靠的是<a href="http://www.expressjs.com.cn/starter/generator.html" target="_blank" rel="external">Express 应用生成器</a>，相当于Express的最佳实践。<br>在使用了一段时间之后，被Express的“回调地狱”，“自定义程度不高”等问题所困扰，于是决定更换至新的框架。</p>
<p>在选择框架时，遵循了自己学习新技术的原则：</p>
<blockquote>
<p>要么找值得学习的，深入学习并理解。要么找适合当前业务，能快速解决问题的。不要在具体某某某个技术上纠结太久。</p>
</blockquote>
<p>这句话也是自己看余果大大的《Web全栈工程师的自我修养》这本书的体会。</p>
<h2 id="选择Koa"><a href="#选择Koa" class="headerlink" title="选择Koa"></a>选择Koa</h2><p>在上面原则的指导下，很容易的就找到了一款符合自己需求的框架：Koa。<br>Koa因为应用了ES6的生成器语法，所以非常优雅的解决了Node.js的回调地狱问题。<br>比如说这样的Ajax代码，看起来就比回调函数的写法优雅很多。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>例子来源： <a href="http://es6.ruanyifeng.com/#docs/generator#yield-语句" target="_blank" rel="external">Generator 函数</a></p>
</blockquote>
<p>虽然yield的写法有点奇怪，但还是可以接受的。</p>
<h3 id="选择Koa2"><a href="#选择Koa2" class="headerlink" title="选择Koa2"></a>选择Koa2</h3><p>同时在Koa的github首页中，看到了Koa2。<br>Koa2应用了ES7的<code>Async/Await</code>来替代Koa1中的生成器函数与yield。<br>所以上一段代码的main函数，在Koa2里长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">await</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">  <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了<code>Async/Await</code>后，整段代码是变的更加好看的。</p>
<h3 id="理解Koa的中间件"><a href="#理解Koa的中间件" class="headerlink" title="理解Koa的中间件"></a>理解Koa的中间件</h3><p>在一开始学习Koa时，是不太理解Koa的中间件级联这个概念的。<br>就是下图这玩意。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/koa.jpg" alt="中间件级联"></p>
<p>这个算是Koa的核心概念了，不理解这个，只能安安心心继续用Express。</p>
<p>还好自己平时爱去看各种开发大会的视频，来提升自己的眼界。所以昨晚正好在慕课网看到了《阿里D2前端技术论坛——2015融合》的大会视频，便开心的点开学习。<br>而第一篇《用 Node.js 构建海量页面渲染服务——by 不四》讲的就有Koa框架，还梳理了Koa的中间件级联这个概念。<br>在不四前辈介绍完Koa的中间件级联后，我发现自己好像理解了。<br>配合着自己之前学习的ES6知识，才发现原来是这样。<br>在这儿我贴一段代码和自己的理解，有兴趣的同学可以看一看。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">var</span> app = koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// x-response-time</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params">next</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 首先启动第一个中间件，记录下时间</span></span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">  <span class="comment">// 进入中间件，并等待返回。</span></span><br><span class="line">  <span class="keyword">yield</span> next;</span><br><span class="line">  <span class="comment">// 返回后，代表操作已完成，记录结束时间并输出。</span></span><br><span class="line">  <span class="keyword">var</span> ms = <span class="keyword">new</span> <span class="built_in">Date</span> - start;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'X-Response-Time'</span>, ms + <span class="string">'ms'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// response</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> *(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 最后一个中间件，将body写成'Hello World'</span></span><br><span class="line">  <span class="keyword">this</span>.body = <span class="string">'Hello World'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></p>
<p>整个的流程，会是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.middleware1 &#123;</span><br><span class="line">  <span class="comment">// (1) do some stuff</span></span><br><span class="line">  .middleware2 &#123;</span><br><span class="line">    <span class="comment">// (2) do some other stuff</span></span><br><span class="line">    .middleware3 &#123;</span><br><span class="line">      <span class="comment">// (3) NO next yield !</span></span><br><span class="line">      <span class="comment">// this.body = 'hello world'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// (4) do some other stuff later</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// (5) do some stuff lastest and return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此，学习Koa的最后一个难关，也被攻克了。</p>
<h2 id="从零组装Koa"><a href="#从零组装Koa" class="headerlink" title="从零组装Koa"></a>从零组装Koa</h2><p>因为对Express的学习和使用，知道了自己对于后台框架的真实需求。<br>所以这回决定不用Koa generator之内的工具，而是自己从零开始，组装一个适合自己的Koa框架。<br>基于Koa2，使用Async/Await，符合自己需求……<br>想想就是很美好的事情呀。</p>
<h3 id="梳理需求"><a href="#梳理需求" class="headerlink" title="梳理需求"></a>梳理需求</h3><p>首先要做的，自然就是梳理自己的需求。看看到底需要什么东西。<br>于是翻出自己前两个月在使用的Express框架，确定了以下要点。</p>
<ol>
<li>路由，创建Rest Api</li>
<li>发送静态HTML文件</li>
<li>设置静态文件目录</li>
<li>发送和读取JSON数据</li>
<li>渲染模板</li>
<li>使用ES6语法完成工作</li>
</ol>
<h3 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h3><p>具体的实现部分，这儿就不再赘述了。就是去github和npm上，寻找一个一个的包并组装在一起了而已。<br>整个项目的亮点就在于：完全符合个人需求，并且使用ES6来完成工作。对我个人而言，用ES6不仅看起来爽，也能提升我的工作效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这周因为胃肠炎，好像也没做啥事情……最大的事儿也只是组装了个Koa框架。<br>因为养病的原因，只能每天看看开发者大会的视频。因为肚子时不时的抽一下，真的很影响工作啊……</p>
<p>今天感觉好了一点，希望病情早日康复~<br>就酱~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Vuex源码阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/17/Vuex源码阅读笔记/" class="article-date">
  	<time datetime="2016-04-17T01:41:19.000Z" itemprop="datePublished">2016-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Vuex源码阅读笔记/">Vuex源码阅读笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>笔记中的Vue与Vuex版本为1.0.21和0.6.2,需要阅读者有使用Vue，Vuex，ES6的经验。</p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>俗话说得好，没有无缘无故的爱，也没有无缘无故的恨，更不会无缘无故的去阅读别人的源代码。<br>之所以会去阅读Vuex的源代码，是因为在刚开始接触Vuex时，就在官方文档的Actions部分，看到这么一句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the simplest action</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  store.dispatch(<span class="string">'INCREMENT'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a action with additional arguments</span></span><br><span class="line"><span class="comment">// with ES2015 argument destructuring</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementBy</span> (<span class="params">&#123; dispatch &#125;, amount</span>) </span>&#123;</span><br><span class="line">  dispatch(<span class="string">'INCREMENT'</span>, amount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的Action还好说，能看懂，但是下面使用ES6写法的Action是什么鬼呀喂（摔！）<br>虽然知道有解构赋值，但是那个<code>{ dispatch }</code>又是从哪儿冒出来的呀喂！明明我在调用时，没有传这个参数呀！<br>之前因为赶项目进度，所以抱着能用就行的态度，也就没管那么多。如今有了空闲时间，必须好好钻研一下呀。<br>而钻研最好的方式，就是阅读Vuex的源代码。这样就能弄清楚，那个<code>{ dispatch }</code>到底从哪儿冒出来的。</p>
<h3 id="Vuex源代码简介"><a href="#Vuex源代码简介" class="headerlink" title="Vuex源代码简介"></a>Vuex源代码简介</h3><p>Vuex的源代码量挺少的，加起来也才600行不到，但是其中大量使用了ES6的语法，且部分功能（如Vuex初始化)使用到了Vue。所以读起来还是有些费劲的。<br>整个Vuex的源代码，核心内容包括两部分。一部分是Store的构造函数，另一部分则是Vuex的初始化函数。<br>而刚才问题的答案，就在第二部分。</p>
<h2 id="问题场景还原"><a href="#问题场景还原" class="headerlink" title="问题场景还原"></a>问题场景还原</h2><p>首先要介绍的，就是Vuex在Vue项目中的初始化。这儿贴一段代码：<br>首先是Vuex中，我写的Actions源代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global/Vuex/action.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getMe = (&#123; dispatch &#125;) =&gt; &#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 异步操作，获取用户信息，并存入Vuex的state中</span><br><span class="line">   */</span></span><br><span class="line">  res.user.get_me()</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    dispatch(<span class="string">'GET_ME'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个则是顶层组件，调用store的地方。由于Vuex的特点，store只需要在最顶层的组件声明一次。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./Vuex/store.js'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    store</span><br><span class="line">  &#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来则是组件中，则是实际调用Vuex的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.vue</span></span><br><span class="line"><span class="keyword">import</span> &#123; getMe &#125; <span class="keyword">from</span> <span class="string">'./../global/Vuex/action'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  vuex: &#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">      getMe</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">      <span class="comment">// 从state中获取信息</span></span><br><span class="line">      user: state =&gt; state.user</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ready() &#123;</span><br><span class="line">    <span class="comment">// 开始获取用户信息</span></span><br><span class="line">    <span class="keyword">this</span>.getMe()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这儿，可以很明显的看出，我在使用<code>this.getMe()</code>时，是没有任何参数的。但是在<code>getMe</code>函数的定义中，是需要解构赋值出<code>{dispatch}</code>的。<br>就好比说这个：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">&#123; x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getX(&#123; x: <span class="number">3</span>, y: <span class="number">5</span> &#125;)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>你得传入相应的参数，才能进行解构赋值。<br>同时，我注意到在Vuex的Actions调用，需要在Vue的options的Vuex.actions中先声明，之后才能使用。<br>那么，一定是Vuex对这个Action动了手脚。（逃）<br>而动手脚的代码，就存在于Vuex源代码的<code>override.js</code>中。这个文件，是用于初始化Vuex的。</p>
<h2 id="Vuex的初始化"><a href="#Vuex的初始化" class="headerlink" title="Vuex的初始化"></a>Vuex的初始化</h2><p>在<code>override.js</code>中，有个<code>vuexInit</code>的函数。看名字就知道，这是拿来初始化Vuex的。<br>在代码开头，有这么一句：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line"><span class="keyword">const</span> &#123; store, vuex &#125; = options</span><br><span class="line"><span class="comment">// 感觉解构赋值真的很棒，这样写能省很多时间。</span></span><br><span class="line"><span class="comment">// 下面的是老写法</span></span><br><span class="line"><span class="comment">// const store = options.store</span></span><br><span class="line"><span class="comment">// const vuex = options.vuex</span></span><br></pre></td></tr></table></figure></p>
<p>在这儿，用于是在Vue中调用，所以this指向Vue,而this.$options则是Vue的配置项。<br>也就是写Vue组件时的：<br><code>export default {……一些配置}</code><br>这里，就把Vue配置项的store和vuex抽离出来了。</p>
<h3 id="搜寻store"><a href="#搜寻store" class="headerlink" title="搜寻store"></a>搜寻store</h3><p>接下来，则看到了Vuex源代码的精妙之处：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store injection</span></span><br><span class="line"><span class="keyword">if</span> (store) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store = store</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">  <span class="keyword">this</span>.$store = options.parent.$store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解构赋值并不是一定成功的，如果store在options中不存在，那么store就会是undefined。但是我们需要找store。<br>于是Vuex提供了向父级（Vue中的功能）寻找store的功能。不难看出，这儿父级的$store如果不存在，那么其实他也会到自己的父级去寻找。直到找到为止。<br>就想一条锁链一样，一层一层的连到最顶部store。所以在没有找到时，Vuex会给你报个错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了Vuex但没有找到store时的状况</span></span><br><span class="line"><span class="keyword">if</span> (vuex) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.$store) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(</span><br><span class="line">      <span class="string">'[vuex] store not injected. make sure to '</span> +</span><br><span class="line">      <span class="string">'provide the store option in your root component.'</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="对Vuex声明的内容，进行改造"><a href="#对Vuex声明的内容，进行改造" class="headerlink" title="对Vuex声明的内容，进行改造"></a>对Vuex声明的内容，进行改造</h3><p>接下来，则是对Vuex声明的内容，进行改造。<br>首先的是获取Vuex对象的内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; state, getters, actions &#125; = vuex</span><br></pre></td></tr></table></figure></p>
<p>同时，在这儿还看到了对过时API的处理。感觉算是意料之外的惊喜。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handle deprecated state option</span></span><br><span class="line"><span class="comment">// 如果使用state而不是getters来获取Store的数据，则会提示你state已经过时的，你需要使用新的api。</span></span><br><span class="line"><span class="comment">// 但是，这儿也做了兼容，确保升级时服务不会挂掉。</span></span><br><span class="line"><span class="keyword">if</span> (state &amp;&amp; !getters) &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(</span><br><span class="line">    <span class="string">'[vuex] vuex.state option will been deprecated in 1.0. '</span> +</span><br><span class="line">    <span class="string">'Use vuex.getters instead.'</span></span><br><span class="line">  )</span><br><span class="line">  getters = state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，则是对getters和actions的处理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getters</span></span><br><span class="line"><span class="keyword">if</span> (getters) &#123;</span><br><span class="line">  options.computed = options.computed || &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> getters) &#123;</span><br><span class="line">    defineVuexGetter(<span class="keyword">this</span>, key, getters[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">if</span> (actions) &#123;</span><br><span class="line">  options.methods = options.methods || &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> actions) &#123;</span><br><span class="line">    options.methods[key] = makeBoundAction(<span class="keyword">this</span>.$store, actions[key], key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，在这儿对getters和actions都进行了额外处理。<br>在这儿，我们讲述actions的额外处理，至于getters，涉及了过多的Vue，而我不是很熟悉。等我多钻研后，再写吧。</p>
<h2 id="Actions的改造"><a href="#Actions的改造" class="headerlink" title="Actions的改造"></a>Actions的改造</h2><p>对整个Actions的改造，首先是Vuex的检测：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">if</span> (actions) &#123;</span><br><span class="line">  <span class="comment">// options.methods是Vue的methods选项</span></span><br><span class="line">  options.methods = options.methods || &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> actions) &#123;</span><br><span class="line">    options.methods[key] = makeBoundAction(<span class="keyword">this</span>.$store, actions[key], key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这儿，我们一点一点的剖析。可以看出，所有的actions，都会被<code>makeBoundAction</code>函数处理，并加入Vue的methods选项中。<br>那么看来，<code>makeBoundAction</code>函数就是我要找的答案了。<br>接下来贴出<code>makeBoundAction</code>函数的源代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Make a bound-to-store version of a raw action function.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Store&#125; store</span><br><span class="line"> * @param &#123;Function&#125; action</span><br><span class="line"> * @param &#123;String&#125; key</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeBoundAction</span>(<span class="params">store, action, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">`[vuex] Action bound to key 'vuex.actions.<span class="subst">$&#123;key&#125;</span>' is not a function.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">vuexBoundAction</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> action.call(<span class="keyword">this</span>, store, ...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事情到这儿，其实已经豁然明朗了。<br>我在Vuex中传入的actions，实际会被处理为<code>vuexBoundAction</code>，并加入options.methods中。<br>在调用这个函数时，实际上的action会使用call，来改变this指向并传入store作为第一个参数。而store是有dispatch这个函数的。<br>那么，在我传入<code>{dispatch}</code>时，自然而然就会解构赋值。<br>这样的话，也形成了闭包，确保action能访问到store。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天应该算是解决了心中的一个大疑惑，还是那句话：</p>
<blockquote>
<p>没有无缘无故的爱，也没有无缘无故的恨，更没有无缘无故冒出来的代码。</p>
</blockquote>
<p>整个源代码读下来一遍，虽然有些部分不太理解，但是对ES6和一些代码的使用的理解又加深了一步。比如这回就巩固了我关于ES6解构赋值的知识。而且还收获了很多别的东西。总而言之，收获颇丰~<br>最后的，依然是那句话：前端路漫漫，且行且歌。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ES6学习之解构赋值" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/16/ES6学习之解构赋值/" class="article-date">
  	<time datetime="2016-04-16T12:53:29.000Z" itemprop="datePublished">2016-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/16/ES6学习之解构赋值/">ES6学习之解构赋值</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文选自我在SegmentFault的#21天阅读分享#中，所记录的两篇笔记。<br>因为对自己帮助较大，所以分享在此。</p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前两天在项目中，需要应用到vuex（类似redux的状态管理工具）。而vuex中，关于变量的赋值是ES6中的解构赋值。<br>恰巧今天在看犀牛书时，也看到了关于解构赋值的介绍，所以今天准备专门学习解构赋值。</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>之前我们声明变量，是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> two = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>这种变量声明的方式，写的少了还好说。写多了，却会感觉繁琐。也容易出错。<br>而ES6中，关于解构赋值的写法，是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [one, two] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">console</span>.log(one)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(two)</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>这样的话，一次性就命名了两个变量。<br>但只是这样的话，功能其实是不够用的。<br>结构赋值还支持如下的形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [one,,three,] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(three)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>这种方式，可以留空位，从而是变量赋值达到精准的要求。<br>在阮一峰老师的ES6文档中，关于解构赋值有这么一句：</p>
<blockquote>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;z: <span class="number">3</span>, y: <span class="number">2</span>, x: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>现在看来，只是把传入的dispatch参数，给解构赋值了。</p>
<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>先写一个demo。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123;</span><br><span class="line">  foo: <span class="string">"Hi i'm foo"</span>,</span><br><span class="line">  bar: <span class="string">"Hi i'm bar"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="comment">// "Hi i'm foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="comment">// "Hi i'm bar"</span></span><br></pre></td></tr></table></figure></p>
<p>对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<br>在这儿，我设置了foo和bar，自然就取到了相应的变量。<br>但是如果要名字不一样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo: Anotherfoo, bar: Anotherbar &#125; = &#123;</span><br><span class="line">  foo: <span class="string">"Hi i'm foo"</span>,</span><br><span class="line">  bar: <span class="string">"Hi i'm bar"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Anotherfoo)</span><br><span class="line"><span class="string">"Hi i'm foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(Anotherbar)</span><br><span class="line"><span class="string">"Hi i'm bar"</span></span><br></pre></td></tr></table></figure></p>
<p>这儿相当于把获取到的foo值，赋值给Anotherfoo。从而达到变量名不同也能变量赋值的效果。<br>这部分的机制，就借用阮一峰老师的话语：</p>
<blockquote>
<p>这实际上说明，对象的解构赋值是下面形式的简写</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo: foo, bar: bar &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，真正被赋值的是变量baz，而不是模式foo </p>
<p>同时之前在使用vuex中，对这一句话很不理解：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  vuex: &#123;</span><br><span class="line">    getters: &#123; ... &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      plus: (&#123; dispatch &#125;) =&gt; dispatch(<span class="string">'INCREMENT'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>2016.04.16更新</p>
</blockquote>
<p>在看到Vuex源代码时，发现有这么一部分:<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span> <span class="params">(&#123;</span><br><span class="line">  state = &#123;&#125;,</span><br><span class="line">  mutations = &#123;&#125;,</span><br><span class="line">  modules = &#123;&#125;,</span><br><span class="line">  middlewares = [],</span><br><span class="line">  <span class="keyword">strict</span> = <span class="keyword">false</span></span><br><span class="line">&#125; = &#123;&#125;)</span></span></span><br></pre></td></tr></table></figure></p>
<p>感兴趣的，是函数中，指定了变量的默认参数并进行了变量解构赋值，但给整个参数又指定了默认值。<br>于是手写了一个demo：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">&#123;</span><br><span class="line">  a = '我是默认参数A',</span><br><span class="line">  b = '我是默认参数B'</span><br><span class="line">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getInfo(&#123; a: <span class="string">'A被覆盖了'</span>, b: <span class="string">'B被覆盖了'</span> &#125;)</span><br><span class="line"><span class="comment">// A被覆盖了 B被覆盖了</span></span><br><span class="line">getInfo(&#123;&#125;)</span><br><span class="line"><span class="comment">// 我是默认参数A 我是默认参数B</span></span><br><span class="line">getInfo()</span><br><span class="line"><span class="comment">// 我是默认参数A 我是默认参数B</span></span><br></pre></td></tr></table></figure></p>
<p>也就是说，这种写法，当函数未传入覆盖默认值的参数，则默认参数将被解构赋值。从而保证默认参数100%得到使用。<br>而不会出现下面，没有传入参数时报错的现象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">&#123;……一些默认参数&#125; = &#123;&#125;</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">getAnotherInfo()</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot match against 'undefined' or 'null'.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套对象的解构"><a href="#嵌套对象的解构" class="headerlink" title="嵌套对象的解构"></a>嵌套对象的解构</h2><p>感觉，这应该是解构赋值中最实用的部分了（个人认为）。<br>因为经常套数据，所以也经常需要把变量的数据取出，转成变量。写多了的话，也是感觉很繁琐的。<br>而ES6，提供了一种全新的解决方式。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> json = &#123;</span><br><span class="line">  <span class="string">'name'</span>: <span class="string">'Lxxyx'</span>,</span><br><span class="line">  <span class="string">'info'</span>: &#123;</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">19</span>,</span><br><span class="line">    <span class="string">'subject'</span>: <span class="string">'HRM'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  info: &#123;</span><br><span class="line">    age,</span><br><span class="line">    subject</span><br><span class="line">  &#125;</span><br><span class="line">&#125; = json</span><br><span class="line"></span><br><span class="line">name <span class="comment">// "Lxxyx"</span></span><br><span class="line">age <span class="comment">//19</span></span><br><span class="line">subject <span class="comment">//"HRM"</span></span><br></pre></td></tr></table></figure></p>
<p>如果直接写变量，代表把相应变量赋值。<br>如果加个<code>:</code>号，则表示操作符。表示要去这里面找变量。<br>如果不理解的话，自己写一遍demo也就理解了。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-前端基础HTTP知识学习之HTTP状态码" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/11/前端基础HTTP知识学习之HTTP状态码/" class="article-date">
  	<time datetime="2016-04-11T01:05:51.000Z" itemprop="datePublished">2016-04-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/11/前端基础HTTP知识学习之HTTP状态码/">前端基础HTTP知识学习之HTTP状态码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前我在我的<a href="http://t.cn/RqfwmLi" target="_blank" rel="external">2016，寒假前端学习计划</a>中，发现自己对HTTP的知识很不熟悉。而作为一个前端，应该对HTTP知识了如指掌。<br>这也是三月份我在找实习的过程中，和几家公司的CTO交流中，他们给我的指点与建议。很感激他们对我的帮助，让我了解到自己知识的漏洞。<br>在补习HTTP相关知识的时候，我手头上有两本书，一本是《图解HTTP》，另外一本是《HTTP权威指南》。<br>在这儿比较推荐前端初学者，去看《图解HTTP》这本书。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/httppic.png" alt="《图解HTTP》"><br>就是图里这本书，整本书深入浅出，书里面的图示非常多。所以整本书读下来非常轻松，却又能恰好掌握HTTP的基础知识。所以我在读的时候，一口气记了十几页的笔记。</p>
<p>那学习HTTP知识，最大的好处就是当前后端交互出错时，至少知道是前端的问题还是后台的问题。这样能省下很多扯皮的时间。（对于我来说）</p>
<h2 id="HTTP与前端"><a href="#HTTP与前端" class="headerlink" title="HTTP与前端"></a>HTTP与前端</h2><p>既然作为HTTP的基础知识，我们这儿就不介绍HTTP的起源，发展，与TCP/IP啥啥啥的关系了，有兴趣的同学可以自己看《图解HTTP》或者《计算机网络》这本书。<br>作为前端，最多接触的HTTP知识是什么？我认为，是状态码。<br>作为一个前端，使用Ajax完成前后端交互，通过Chrome控制台的Network来看资源加载情况等事情，简直和家常便饭一样。<br>比如说，看到 <code>404</code> 就知道这个资源没能加载出来，而看到<code>200</code>就知道这次加载稳了。<br>曾经的我，对于HTTP实际应用的大概了解，就只有这些了。但是这些还不够呀。所以在看完《图解HTTP》时，就过来分享一些我HTTP知识的盲点，希望能对大家有所帮助。</p>
<h2 id="HTTP常见状态码分类"><a href="#HTTP常见状态码分类" class="headerlink" title="HTTP常见状态码分类"></a>HTTP常见状态码分类</h2><p>大家都知道，在进行请求时，会产生各种各样的HTTP状态码，所以在这儿，首先要介绍的就是HTTP的常见状态码。<br>最常见的，就是HTTP 2XX - 5XX了。<br>这儿，我列了一个表格，来描述</p>
<table>
<thead>
<tr>
<th>HTTP状态码</th>
<th style="text-align:center">状态码</th>
<th style="text-align:right">原因解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>2xx</td>
<td style="text-align:center">成功</td>
<td style="text-align:right">请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td style="text-align:center">重定向</td>
<td style="text-align:right">需要附加操作</td>
</tr>
<tr>
<td>4xx</td>
<td style="text-align:center">客户端错误</td>
<td style="text-align:right">服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td style="text-align:center">服务器错误</td>
<td style="text-align:right">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>关于各种状态码的意义，在这儿就一目了然了，比如说，发生<code>4XX</code>时，一般是前端的锅。发生<code>5XX</code>时则是后台的锅。<br>当要设置页面重定向时，应该设置<code>3XX</code>的状态码，而不是在原网页上使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = <span class="string">'http://xxxxx'</span></span><br></pre></td></tr></table></figure></p>
<p>这种方式。（别笑，真的见过这样的……）</p>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><p>这儿，我将会记下几个常见的状态码，虽然《图解HTTP》这本书提供了14个常见的HTTP状态码，但是对我来说，可能知识盲点和常见的也就那几个。<br>所以这儿就着重介绍他们，如果想了解详细的，各位可以自行借阅或购买《HTTP权威指南》这本书，绝对满足你的需求。</p>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX - 成功"></a>2XX - 成功</h3><p>在这儿，首先介绍的是HTTP 200，200的意思很好理解，就是客户端的请求已被处理完毕。</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 - No Content"></a>204 - No Content</h4><p>这个呢，代表服务器请求已被成功处理，但是返回的结果中，是不带实体信息的。</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 - Partial Content"></a>206 - Partial Content</h4><p>表示范围请求，既返回的实体信息只是一部分。比如，返回某张照片的下半部分，某个文本的最后几行。用得好的话，可以大大节省网络传输的流量，达到指哪打哪的效果。</p>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX - 重定向"></a>3XX - 重定向</h3><p>这部分，其实是有点绕的。不过仔细看看，想一想也能很好的分辨。</p>
<h4 id="301-永久重定向"><a href="#301-永久重定向" class="headerlink" title="301 - 永久重定向"></a>301 - 永久重定向</h4><p>永久重定向，告诉客户端以后应从新地址访问。同时书签（如果有的话）也应该更换为新地址。</p>
<h4 id="302-临时重定向"><a href="#302-临时重定向" class="headerlink" title="302 - 临时重定向"></a>302 - 临时重定向</h4><p>告诉客户端我换了位置了，但你还可以用这个地址来访问。现在基本重定向，返回的都是<code>302</code>状态码。</p>
<h4 id="303-临时重定向-POST请求改为GET"><a href="#303-临时重定向-POST请求改为GET" class="headerlink" title="303 - 临时重定向 - POST请求改为GET"></a>303 - 临时重定向 - POST请求改为GET</h4><p>对于POST请求，它表示请求已经被处理，客户端可以<strong>接着使用GET方法</strong>去请求Location里的URI。</p>
<h4 id="307-临时重定向-POST请求不变"><a href="#307-临时重定向-POST请求不变" class="headerlink" title="307 - 临时重定向 - POST请求不变"></a>307 - 临时重定向 - POST请求不变</h4><p>对于POST请求，表示请求还没有被处理，客户端应该向Location里的URI重新发起<strong>POST</strong>请求。</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 - Not Modified"></a>304 - Not Modified</h4><p>这个算是很重要的状态码，常见于网站的缓存处理中。<br>这儿，我摘抄了维基百科的解释：</p>
<blockquote>
<p>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。</p>
</blockquote>
<p><code>304</code>的作用，还是很大的。简单点说就是：我给你发送请求，查看我本地这个资源是否是最新的，如果是，服务器就返回304。浏览器从本地读取缓存，而不用去服务器上请求资源。<br>想深入了解的话，可以阅读这篇文章： <a href="http://www.cnblogs.com/ziyunfei/archive/2012/11/17/2772729.html" target="_blank" rel="external">[译]理解HTTP/304响应</a></p>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX - 客户端错误"></a>4XX - 客户端错误</h3><p>这部分属于客户端错误，也就是说如果出错了，很大可能是前端的锅。</p>
<h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 - Bad Request"></a>400 - Bad Request</h4><p>该状态码表示请求报文存在语法错误，需要修改。</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 - Unauthorized"></a>401 - Unauthorized</h4><p>代表请求未经认证，不给过。</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 - Forbidden"></a>403 - Forbidden</h4><p>服务器拒绝请求，但是不想告诉你理由。</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 - Not Found"></a>404 - Not Found</h4><p>哈哈，这个就是大名鼎鼎的HTTP 404 Not Found 状态码。<br>这个状态码有两层意思，第一层是<strong>请求的资源未找到</strong>,第二层则是和HTTP 403一样，服务器拒绝请求，但是不想告诉你理由。</p>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX - 服务器错误"></a>5XX - 服务器错误</h3><p>这部分属于服务器错误，也就是说如果出错了，则是后台的锅。</p>
<h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 - Internal Server Error"></a>500 - Internal Server Error</h4><p>Internal Server Error翻译成中文就是服务器处理请求出错。也就是后台那儿出了问题，所以发送了500给你。<br>这种时候，放心的找后台报BUG去吧。</p>
<h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 - Service Unavailable"></a>503 - Service Unavailable</h4><p>这个状态码，则是告诉你现在服务器暂时无法处理你的请求，你待会儿再试试。<br>当然，出现这种问题，一般也可以直接找后台。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天所写的HTTP状态码，只是HTTP整个知识的一部分，但却很重要。熟悉常见的HTTP状态码，能帮我们快速定位问题，同时如果你是后台，给出正确的HTTP状态码，也方便自己将来DEBUG。</p>
<p>话说这儿得吐槽一句，那就是七牛的图片上传工具不太方便。在Windows下还好，有个图形界面，自动监控文件夹内容就自动上传的。<br>但是在Mac和Linux下只有纯命令行界面的工具。很是不方便。于是在写这篇博客时，自己用Gulp写了个小工具，专门配合七牛的Node.js SDK，实现自动监控文件变化并上传。<br>怎么说，既然选择做程序员，那么能让电脑帮你完成的，就不要动手啦。<br>况且，这个博客从配置完成的那一天起，我就基本没有折腾过。因为只是想安安静静的写博客而已，目前HEXO和这个主题的效果就挺好的。博客博客，最重要的还是里面的内容。</p>
<p>就酱~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-博客将于近期恢复更新" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/06/博客将于近期恢复更新/" class="article-date">
  	<time datetime="2016-04-05T23:56:35.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/博客将于近期恢复更新/">博客将于近期恢复更新</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="停滞的一个月"><a href="#停滞的一个月" class="headerlink" title="停滞的一个月"></a>停滞的一个月</h2><p>在02-25，我写下了《寒假前端学习总结》。直到今天，整整一个多月的时间，没有去更新博客。在这儿对关注我博客的各位，说声抱歉。<br>因为所处的学期是大二下学期，课程超级多。而且因为刚开学，学生会和工作室两头的事情也忙得不可开交。<br>所以整整一个月，都是忙过来的。<br>不过这一个月，倒也不是全无收获。</p>
<h2 id="二十一天阅读分享"><a href="#二十一天阅读分享" class="headerlink" title="二十一天阅读分享"></a>二十一天阅读分享</h2><p>虽然在三月份，一篇博客都没写，但是我也没有停止学习。<br>在三月初参加了前端早读课与Segmentfault的二十一天阅读分享活动。要求连续二十一天，每天都写一篇技术笔记。<br>很高兴的是我坚持下来了，Segmentfault的奖品就是我一直想买的那本《ES6 标准入门》。所以算是有所收获。<br>近期会把一些自己写的比较好的笔记誊抄到博客里。<br>这是我的笔记链接。</p>
<blockquote>
<p><a href="https://segmentfault.com/u/lxxyx/notes" target="_blank" rel="external">Lxxyx 的笔记</a></p>
</blockquote>
<h2 id="校招与暑期实习"><a href="#校招与暑期实习" class="headerlink" title="校招与暑期实习"></a>校招与暑期实习</h2><p>三月份还有不得不提的一件事，就是校招与暑期实习了。</p>
<h3 id="校招"><a href="#校招" class="headerlink" title="校招"></a>校招</h3><p>因为大二结束，就会退出现在的工作室。相当于没有项目可以做，练手的机会也很少，所以想着找份实习。<br>因为是大二，只有暑期能去实习。所以时间上算是比较尴尬的，也很少会有公司去招聘一个大二的实习生（总觉得技术不够或者不靠谱等等）。<br>第一个想到的就是BAT这种大公司，因为只有这种大公司会招聘暑期实习生。所以很高兴的找了阿里的一个前辈帮我内推，幸运的是内推申请过了。<br>衰的是在三月四号进行了第一轮面试，在今天，简历的状态依然是在评估中。据消息是已经挂了。<br>====&gt; 4.9号更新 确实，已经挂了。</p>
<h3 id="暑期实习"><a href="#暑期实习" class="headerlink" title="暑期实习"></a>暑期实习</h3><p>其实中间还是有些慌乱的，因为想着如果暑期找不到相应的前端实习，自己只能继续闭门造车了。还好，在对路上申请实习，获得了三个实习机会。<br>于是选择了最喜欢的一家，约定好暑期去实习。两轮电话面试，CTO和另外一个前辈给我的感觉都非常好。<br>怎么说呢，应该是以进入一家这样的公司为荣吧。</p>
<h2 id="博客将于近期恢复更新"><a href="#博客将于近期恢复更新" class="headerlink" title="博客将于近期恢复更新"></a>博客将于近期恢复更新</h2><p>这是今天的正题，博客这种东西，不一直写下去其实是没有意义的。<br>今后会比较侧重前端相关的知识，和一些自己学习的感悟。<br>希望能帮助到大家，也算是给自己的知识备个份，需要的时候也能方便的查阅。<br>好些天没有写博客，说实话写这篇博客的时候自己的脑子是不连贯的。<br>至于写博客的好处，可以参见阮一峰老师的文章：</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2006/12/why_i_keep_blogging.html" target="_blank" rel="external">为什么要写Blog？</a></p>
</blockquote>
<p>就酱，吃早餐去啦。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/2016，寒假前端学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/25/寒假前端学习/2016，寒假前端学习总结/" class="article-date">
  	<time datetime="2016-02-25T01:05:04.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/寒假前端学习/2016，寒假前端学习总结/">2016，寒假前端学习总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天是2.25，寒假的最后一天。<br>一月九号我写下《寒假前端学习计划》一文作为寒假的开始，今天我同样写下《寒假前端学习总结》一文作为寒假的结束。</p>
<h2 id="疯狂生长"><a href="#疯狂生长" class="headerlink" title="疯狂生长"></a>疯狂生长</h2><p>给自己的寒假，定的总结词是“疯狂生长”。这也算是自己过的最为充实，最为努力的一个寒假。每天起床后，便<br>一头扎进编程的海洋中，从早到晚，乐此不疲。</p>
<h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>寒假带了三本书回家：</p>
<ol>
<li>《JavaScript高级程序设计》</li>
<li>《JavaScript设计模式与开发实践》</li>
<li>《计算机科学导论》</li>
</ol>
<p>颇为自豪的是，三本书我都看完了。<br>第一本《JavaScript高级程序设计》算是二战了，有种常看常新的感觉。感觉之前在做项目时，碰到的很多JavaScript问题，都可以在书上找到答案。难怪被人称之为红宝书。</p>
<p>第二本《JavaScript设计模式与开发实践》，给我带来了极大的震撼。书中每一个介绍的设计模式，都会有相应的实际案例相配套。从未有见过，代码还能以那样一种精巧的方式书写。算是在学习之余，极大的开拓了自己的眼界。从一个真正的程序员的视角，去审视前端与其性能。</p>
<p>第三本《计算机科学导论》，是我顺手带回家。结果在某一天的下午，翻开第一页后变便一口气连读十几个小时的书籍。要说《JavaScript高级程序设计》让我拥有了对JavaScript的大局观，那么《计算机科学导论》便是让我领略到计算机科学的万千精彩。</p>
<h3 id="做项目"><a href="#做项目" class="headerlink" title="做项目"></a>做项目</h3><p>俗话说的好，光说不练假把式。在看书之余，自然就是不断的练习。把书上看到的设计模式，新方法运用到实际项目中，对自己之前的代码进行重构等。</p>
<h4 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h4><p>之前一直做的是PC端，定宽的网页。对于移动端，可以算是一无所知。（用bootstrap等框架做出的网页虽然能适应移动端，但总觉得不算是真正的能力，逃）<br>于是把移动端开发的学习放进了寒假计划中。<br>先去网上看了看移动端开发的资料，被一大堆的dpi，px，ppi,dpr弄得晕头转向。随后便打开了慕课网，跟着视频学习。下面是两节学完的课程。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/end1.png" alt="移动端开发"><br>学习了一门《移动web入门》，又跟着慕课网，写了一个春节贺卡。顿时感觉有信心多了。<br>写完贺卡的我，开始思考该写点啥来巩固一下刚学的知识。恰巧看到了张秋怡学姐（学长？）的前端简历，顿时惊为天人。同时张秋怡学姐还做了响应式设计。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/end3.png" alt="张秋怡学姐の简历"></p>
<p>遂开始仿写学姐的简历。整个过程历时三天，没有去Github看源代码。素材也自己找。使用了Gulp+Sass等工具。可以说是像素级模仿。全面巩固了之前所学的移动端知识。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/end4.png" alt="我仿写の简历"></p>
<p>当然，网页底部带上了版权声明，证明是张秋怡学姐的作品。我只是仿写。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/endbq.png" alt="版权声明"></p>
<p>简历目前挂在我的服务器上，使用<code>Express</code>为后台，<code>Jade</code>作为渲染引擎，<code>Mongodb</code>为数据库。因为想做一个简历生成页面，只需要填入信息，便可以自动生成张秋怡学姐那样的简历。同时呢也希望自己能在这个暑假，找到一份实习工作。</p>
<blockquote>
<p><a href="http://115.159.148.159/" target="_blank" rel="external">简历地址–刘子健，前端开发实习生</a></p>
</blockquote>
<h4 id="工作室项目"><a href="#工作室项目" class="headerlink" title="工作室项目"></a>工作室项目</h4><p>工作室的项目，是内网改造。使用了Vue+Vue-Router，来完成SPA的编写。寒假一个月，算是深入学习与使用了Vue这个框架，不得不感慨，Vue真的是太好用了。</p>
<h4 id="工具学习"><a href="#工具学习" class="headerlink" title="工具学习"></a>工具学习</h4><p>工具的学习，算是少的。因为在知乎上看到了这个问题：</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/39662828" target="_blank" rel="external">前端深入到什么程度才可以本科就拿到bat google 的offer？</a></p>
</blockquote>
<p>其中，一个我非常崇拜的前辈贺师俊回答了这个问题。</p>
<blockquote>
<p>才大二，少做（react/angular/php）hello world级别的事情（除非你能作出点真的有点实际价值的产品），先打基础。</p>
</blockquote>
<p>于是警醒了我，让我开始了补基础的旅程。<br>不过为了加速开发，还是学了一点点工具的。比如Gulp,Sass,Webpack,forever等<br>最具代表性算是Gulp了。<br>半年前想学习的时候，觉得怎么看都不理解Gulp的运作方式，遂放弃。结果寒假时候看了看Gulp的用法，最多半小时，便熟练上手使用。想来是这半年的前端与Node学习，让我在不知不觉中理解了Gulp的运转方式。自然上手就超级快。</p>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><p>这书也看了，项目也写了。自然就要写文章总结了。<br>整个寒假下来，一共写了十六篇文章。包括前端学习，管理学习，随笔杂文等。其中，前端学习10篇，主要发表于自己的博客、Segmentfault和慕课网中。<br>写博客两个月中，给我的博客网站带来了2.3k的浏览量。算是小有成就~<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/end6.png" alt="博客浏览量"></p>
<p>同时，因为发表文章的缘故，在Segmentfault获得了1.2k的声望。这在我前两个月，是想都不敢想的事情。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/end8.png" alt="Segmentfault"></p>
<p>发表在慕课网的文章，获得了征文大赛的奖项，也得到了慕课网二月份优秀作者的称号~<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/end7.png" alt="慕课网"></p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>要说寒假的感觉，就是自己更勇敢了。<br>之前还因为自己是个文科生，而惴惴不安，整日思考自己能否学好编程。<br>在前辈的帮助，指引与自己努力之下，一个寒假过后，感觉整个世界都是亮堂的。要说从哪儿开始的话，就是提笔写下第一篇博客之时,My life has changed.</p>
<p>前方路漫漫，编程的世界却又如此绚丽。一路前进，且行且歌!</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(10)——理解DOM事件流的三个阶段" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/17/寒假前端学习/寒假前端学习(10)——理解DOM事件流的三个阶段/" class="article-date">
  	<time datetime="2016-02-17T02:25:20.000Z" itemprop="datePublished">2016-02-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/17/寒假前端学习/寒假前端学习(10)——理解DOM事件流的三个阶段/">寒假前端学习(10)——理解DOM事件流的三个阶段</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要解决两个问题：</p>
<ol>
<li>什么是事件流</li>
<li>DOM事件流的三个阶段</li>
</ol>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在学习前端的大半年来，对DOM事件了解甚少。一般也只是用用<code>onclick</code>来绑定个点击事件。在寒假深入学习JavaScript时，愈发觉得自己对DOM事件了解不够，遂打开我的《JavaScript高级程序设计》，翻到DOM事件那一章，开始第二次学习之旅。<br>当然，DOM事件所囊括的知识较为庞杂，所以本文专注与自己学习时所碰到的难点，DOM事件流。</p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流的概念，在现今的JavaScript中随处可见。比如说React中的单向数据流，Node中的流，又或是今天本文所讲的DOM事件流。都是流的一种生动体现。<br>至于流的具体概念，我们采用下文的解释：</p>
<blockquote>
<p>用术语说流是对输入输出设备的抽象。以程序的角度说，流是具有方向的数据。<br><a href="http://taobaofed.org/blog/2016/01/28/nodejs-stream/" target="_blank" rel="external">通通连起来——无处不在的流 淘宝FED–愈之</a></p>
</blockquote>
<h2 id="事件流之事件冒泡与事件捕获"><a href="#事件流之事件冒泡与事件捕获" class="headerlink" title="事件流之事件冒泡与事件捕获"></a>事件流之事件冒泡与事件捕获</h2><p>在浏览器发展的过程中，开发团队遇到了一个问题。那就是页面中的哪一部分拥有特定的事件？<br>可以想象画在一张纸上的一组同心圆，如果你把手指放在圆心上，那么你的手指指向的其实不是一个圆，而是纸上所有的圆。放到实际页面中就是，你点击一个按钮，事实上你还同时点击了按钮所有的父元素。<br>开发团队的问题就在于，当点击按钮时，是按钮最外层的父元素先收到事件并执行，还是具体元素先收到事件并执行？所以这儿引入了事件流的概念。</p>
<blockquote>
<p>事件流所描述的就是从页面中接受事件的顺序。</p>
</blockquote>
<p>因为有两种观点，所以事件流也有两种，分别是事件冒泡和事件捕获。现行的主流是事件冒泡。</p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点。<br>举个栗子，就很容易明白了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"clickMe"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们给<code>button</code>和它的父元素，加入点击事件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'clickMe'</span>);</span><br><span class="line"></span><br><span class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1. You click Button'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2. You click body'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3. You click document'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4. You click window'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>效果如图所示：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/dom1.png" alt="事件冒泡示例图"></p>
<p>在代码所示的页面中，如果点击了button，那么这个点击事件会按如下的顺序传播（Chrome浏览器）：</p>
<ol>
<li>button</li>
<li>body</li>
<li>document</li>
<li>window</li>
</ol>
<p>也就是说，click事件首先在<code>&lt;button&gt;</code>元素上发生，然后逐级向上传播。这就是事件冒泡。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获的概念，与事件冒泡正好相反。它认为当某个事件发生时，父元素应该更早接收到事件，具体元素则最后接收到事件。比如说刚才的demo，如果是事件捕获的话，事件发生顺序会是这样的：</p>
<ol>
<li>window</li>
<li>document</li>
<li>body</li>
<li>button</li>
</ol>
<p><img src="http://7xoxxe.com1.z0.glb.clouddn.com/dom2.png" alt="事件捕获示例图"><br>当然，由于时代更迭，事件冒泡方式更胜一筹。所以放心的使用事件冒泡，有特殊需要再使用事件捕获即可。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>DOM事件流包括三个阶段。</p>
<ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<p>如图所示（图片源于网络，若侵权请告知）：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/dom3.png" alt="DOM事件流示例图"></p>
<h3 id="1-事件捕获阶段"><a href="#1-事件捕获阶段" class="headerlink" title="1. 事件捕获阶段"></a>1. 事件捕获阶段</h3><p>也就是说，当事件发生时，首先发生的是事件捕获，为父元素截获事件提供了机会。<br>例如，我把上面的Demo中，window点击事件更改为使用事件捕获模式。(addEventListener最后一个参数，<em>为true则代表使用事件捕获模式</em>，false则表示使用事件冒泡模式。不理解的可以去学习一下addEventListener函数的使用)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'4. You click window'</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>此时，点击button的效果是这样的。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/dom4.png" alt="DOM事件流中事件捕获示例图"></p>
<p>可以看到，点击事件先被父元素截获了，且该函数只在事件捕获阶段起作用。</p>
<h3 id="处于目标与事件冒泡阶段"><a href="#处于目标与事件冒泡阶段" class="headerlink" title="处于目标与事件冒泡阶段"></a>处于目标与事件冒泡阶段</h3><p>事件到了具体元素时，在具体元素上发生，并且被看成冒泡阶段的一部分。<br>随后，冒泡阶段发生，事件开始冒泡。</p>
<h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡过程，是可以被阻止的。防止事件冒泡而带来不必要的错误和困扰。<br>这个方法就是:<code>stopPropagation()</code></p>
<blockquote>
<p>stopPropagation() 方法<br>终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。</p>
</blockquote>
<p>我们对<code>button</code>的click事件做一些改造。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// event为事件对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'1. You click Button'</span>);</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Stop Propagation!'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>点击后，效果如下图：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/dom5.png" alt="阻止冒泡示例图"></p>
<p>不难看出，事件在到达具体元素后，停止了冒泡。但不影响父元素的事件捕获。</p>
<h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>事件流：描述的就是从页面中接受事件的顺序。分有事件冒泡与事件捕获两种。<br>DOM事件流的三个阶段：</p>
<ol>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ol>
<p>在学习DOM事件的过程中，了解了DOM事件的三个阶段，也知道事件冒泡是干啥用的，又如何阻止。配合前期所学的二叉树的相关知识，受益匪浅。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Lxxyx
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71744638-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




  </div>
</body>
</html>