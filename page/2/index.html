<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Lxxyx的前端乐园</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文科生，热爱前端与Node.js。2018年毕业">
<meta property="og:type" content="website">
<meta property="og:title" content="Lxxyx的前端乐园">
<meta property="og:url" content="http://www.lxxyx.win/page/2/index.html">
<meta property="og:site_name" content="Lxxyx的前端乐园">
<meta property="og:description" content="文科生，热爱前端与Node.js。2018年毕业">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lxxyx的前端乐园">
<meta name="twitter:description" content="文科生，热爱前端与Node.js。2018年毕业">
  
    <link rel="alternative" href="/atom.xml" title="Lxxyx的前端乐园" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xk109.com1.z0.glb.clouddn.com/blog-head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Lxxyx</a></h1>
		</hgroup>

		
		<p class="header-subtitle">文科生の前端生活</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/前端">前端之路</a></li>
				        
							<li><a href="/tags/管理">管理学习</a></li>
				        
							<li><a href="/tags/随笔">随笔杂文</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Lxxyx" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Lxxyx" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="mailto:Lxxyxzj@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/前端/" style="font-size: 20px;">前端</a> <a href="/tags/管理/" style="font-size: 10px;">管理</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://guowenfh.github.io/">三省吾身丶丶</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zhibinnet.com/">island的个人网站</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://ienning.com/">Enning</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">某211的纯文科生，2018年毕业。热爱前端与Node.js。在学校的网站工作室中担任前端开发的工作，有实际项目经验。将来想成为一名前端工程师。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Lxxyx</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://7xk109.com1.z0.glb.clouddn.com/blog-head.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Lxxyx</h1>
			</hgroup>
			
			<p class="header-subtitle">文科生の前端生活</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/前端">前端之路</a></li>
		        
					<li><a href="/tags/管理">管理学习</a></li>
		        
					<li><a href="/tags/随笔">随笔杂文</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Lxxyx" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Lxxyx" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="mailto:Lxxyxzj@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-寒假前端学习/寒假前端学习(9)——理解CSS盒模型与宽高计算" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/09/寒假前端学习/寒假前端学习(9)——理解CSS盒模型与宽高计算/" class="article-date">
  	<time datetime="2016-02-09T11:46:17.000Z" itemprop="datePublished">2016-02-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/09/寒假前端学习/寒假前端学习(9)——理解CSS盒模型与宽高计算/">寒假前端学习(9)——理解CSS盒模型与宽高计算</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>盒模型是CSS的核心知识，属于那种不掌握好，在实际工作中就容易犯迷糊的知识。<br>至于本篇文章，主要解决一个问题，那就是CSS盒模型的计算方法。至于别的知识，也算是自己回忆和复习一次。</p>
<h2 id="盒模型的构成"><a href="#盒模型的构成" class="headerlink" title="盒模型的构成"></a>盒模型的构成</h2><p>关于盒模型的构成，算是前端的基础知识了。网络上关于这方面的知识也是多如牛毛。所以这儿我就用Chrome浏览器控制台的盒模型图。（毕竟最贴近实际开发环境）<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/box1.png" alt="盒模型构成图"><br>可以看到盒模型由<code>margin</code>,<code>border</code>,<code>padding</code>,<code>content（中心部分0x0的那个框）</code>四部分组成。<br>如果要形象化的理解呢，我们举个栗子~</p>
<p>这儿有一个仓库，仓库里是各式各样的箱子。仓库代表网页，箱子代表独立的div。<br>两个箱子之间的空隙，就是margin。<br>箱子当然有自己边框了，每个箱子边框的厚度不一。这个边框，就是border。厚度呢就是border的大小。<br>箱子里面当然也装着各式各样的货物，箱子里面所有的货物，就是content。<br>但是货物也有可能没把箱子堆满，那么箱子内除去货物的空白部分，就是padding了。</p>
<p>这就是我对盒模型在现实中的理解。</p>
<h2 id="盒模型的宽度计算"><a href="#盒模型的宽度计算" class="headerlink" title="盒模型的宽度计算"></a>盒模型的宽度计算</h2><p>盒模型的宽度计算，不复杂但也不好玩。因为一个盒模型的宽度，不只是计算其content的宽度，还会加上元素的边框与内边距。</p>
<p>用个demo，就很好理解了。在demo中，两个div的宽度是一致的。(demo出处在底部)<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.simple &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  margin: 20px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.fancy &#123;</span><br><span class="line">  width: 500px;</span><br><span class="line">  margin: 20px auto;</span><br><span class="line">  padding: 50px;</span><br><span class="line">  border-width: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但实际情况，却是这样的:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/box2.png" alt="盒模型demo"><br>这是因为盒模型计算宽度时，加上了padding和border的宽度。所以第二个元素看起来要比第一个元素大。</p>
<p>这样对于计算盒模型宽度是不利的，因为比较繁琐。于是后来人为了解决这个问题，在CSS3中给盒模型加入了新属性：<code>box-sizing</code>。</p>
<h2 id="CSS3的box-sizing"><a href="#CSS3的box-sizing" class="headerlink" title="CSS3的box-sizing"></a>CSS3的box-sizing</h2><p><code>box-sizing</code>共两个属性，一个是<code>content-box</code>，一个是<code>border-box</code>。<br>设置为<code>content-box</code>则盒模型宽度计算方法同CSS2.1，计算内边距和边框。所以这儿我们着重讲解<code>border-box</code>。</p>
<p>当设置一个盒模型为<code>box-sizing: border-box</code>时，这个盒子的内边距和边框都不会再增加它的宽度。</p>
<p>继续看第二个demo。在这儿，我们给所有盒模型统一设置<code>box-sizing: border-box</code>。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">     <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">          <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.simple</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fancy</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border</span>: solid blue <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，出来的效果会是这样的。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/box3.png" alt="box-sizing demo"></p>
<p>可以看到两个盒模型的宽度一致了。<br>这是因为之前设置的宽度，是元素的宽度。而内边距和边框在元素宽度外绘制。<br>而设置<code>border-box</code>时，内边距和边框都在设定的宽度内进行绘制。元素宽度需要由设定宽度减去内边距和边框得到。</p>
<p>怎么样，是不是很容易理解呢？至于高度，计算原理同上。这儿就不赘述啦。</p>
<h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><p>算是个自己写网页时经常碰到的问题，那就是如果给一个元素设置<code>background</code>时，背景颜色的范围将包括内边距。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要说总结的话，这节应该是自己学的最轻松的一部分。之前都是盲点和难点，这里却只是似懂非懂。看了看文档就瞬间明白了。然后想了想，还是写篇博客出来，因为好记性不如烂笔头~</p>
<p>然后再放上参考链接，有兴趣多了解的同学，也可以点开看看。</p>
<p>前端路漫漫，且行且歌~</p>
<p>参考链接：</p>
<blockquote>
<p><a href="http://zh.learnlayout.com/box-model.html" target="_blank" rel="external">CSS - 盒模型（也是demo来源）</a><br><a href="http://zh.learnlayout.com/box-sizing.html" target="_blank" rel="external">CSS - 盒模型 - box-sizing</a><br><a href="http://www.w3school.com.cn/cssref/pr_box-sizing.asp" target="_blank" rel="external">CSS3 box-sizing 属性</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(8)——理解CSS浮动与清除浮动" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/06/寒假前端学习/寒假前端学习(8)——理解CSS浮动与清除浮动/" class="article-date">
  	<time datetime="2016-02-06T04:49:01.000Z" itemprop="datePublished">2016-02-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/06/寒假前端学习/寒假前端学习(8)——理解CSS浮动与清除浮动/">寒假前端学习(8)——理解CSS浮动与清除浮动</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文主要探讨两个问题：</p>
<ol>
<li>为什么CSS设置浮动会引起父元素塌陷</li>
<li>为什么设置<code>clear:both</code>能清除浮动，并撑开父元素。</li>
</ol>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>CSS的浮动，算是我在写网页时用的最多的属性之一。但要说我对浮动的了解程度的话，只能说“知其然而不知其所以然”。虽然很多人都说浮动会用就行，但是要想成为一个优秀的前端，对这些常用属性得知根知底。</p>
<p>恰巧在慕课网，张鑫旭老师开了《CSS深入理解之float浮动》这门课。链接在文末，有兴趣的可以听听，老师讲课风格很风趣……</p>
<h2 id="Float的历史"><a href="#Float的历史" class="headerlink" title="Float的历史"></a>Float的历史</h2><p>Float设计的初衷，是为了实现文字环绕效果。就像下图展示的一样（图片源于w3school）：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float1.png" alt="Float效果图"><br>嗯，就这么简单。</p>
<h2 id="Float引起的父元素高度塌陷BUG？"><a href="#Float引起的父元素高度塌陷BUG？" class="headerlink" title="Float引起的父元素高度塌陷BUG？"></a>Float引起的父元素高度塌陷BUG？</h2><p>在这儿，我们用一个例子来说明子元素设置浮动，从而引起父元素高度塌陷的问题。<br>首先写一个div，里面插入一张图片。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./source/head.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们再给div设置一个border，为了让大家看的清楚。<br>CSS设置如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后效果是这样的:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float2.png" alt="未Float的效果图"><br>通过chrome控制台，可以看到此时div的高度为464px。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float3.png" alt="div高度"></p>
<p>接下来，我们给那张图片添加浮动效果。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看网页，发现父元素已经塌陷了,之前的边框也消失不见了，成为一条线了。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float4.png" alt="Float后的效果图"><br>此时再去控制台查看div的高度，高度为0px。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float5.png" alt="div高度"></p>
<h3 id="不，不是BUG"><a href="#不，不是BUG" class="headerlink" title="不，不是BUG"></a>不，不是BUG</h3><p>很多人把这个现象称为浮动带来的BUG。但从一开始Float的用途来思考：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="built_in">Float</span>设计的初衷，是为了实现文字环绕效果。”</span><br></pre></td></tr></table></figure></p>
<p>那么，在那远古蛮荒的互联网时代，要如何实现文字环绕图片的效果呢？机智的程序员加入了Float属性，也引入了子元素浮动，父元素高度塌陷的特性。<br>看到这句话的时候，我思考了很久。因为无法理解父元素高度塌陷为何能让文字环绕图片。于是把视频来来回回看了十多遍，又手写了个demo，总算理解了。</p>
<p>总结来说，核心要点在于一句话：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“浮动元素会脱离文档流。”</span><br></pre></td></tr></table></figure></p>
<p>至于文档流是啥，我这儿就不介绍了。但浮动的元素脱离了文档流，所以是不计算高度的。<br>在此，我们加入一段话，看看div的高度。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float6.png" alt="段落高度"><br>从图中可以看出，div因为段落的加入，高度被撑开了。</p>
<p>所以子元素浮动引起父元素高度塌陷的原因如下：<br>因为没有预先设置div高度，所以div高度由其包含的子元素高度决定。而浮动脱离文档流，所以图片并不会被计算高度。此时的div中，相当于div中子元素高度为0，所以发生了父元素高度塌陷现象。</p>
<h3 id="文字环绕效果的实现"><a href="#文字环绕效果的实现" class="headerlink" title="文字环绕效果的实现"></a>文字环绕效果的实现</h3><p>那么，文字环绕效果是如何实现的？<br>其实讲起来也很简单，因为父元素高度塌陷，所以文字会按正常顺序排列，无视图片高度。而图片宽带又还在，所以实现了文字环绕效果。</p>
<h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>介绍完浮动，自然要介绍清除浮动。在此，我们不具体的去探讨各种清除浮动的方式。而是去探讨，为何设置<code>clear:both</code>能清除浮动，并撑开父元素。</p>
<h3 id="clear-both的作用"><a href="#clear-both的作用" class="headerlink" title="clear:both的作用"></a>clear:both的作用</h3><p>clear:both的作用，对各位来说可以算是耳熟能详了。至于clear的left,right等属性，我们这儿就不一一列举了。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear: both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在父元素内的底部，加入这一行代码。看图易知，父元素因为子元素设置浮动而高度塌陷的问题，已经被解决了。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float7.png" alt="加入clear: both后的效果"></p>
<p>然后如果只是会用<code>clear:both</code>，又怎么能满足我的求知欲呢？相比与这行代码产生的作用，我更关心为什么这行代码能清除浮动。<br>对此，我继续翻阅文档。<br>在w3school中，clear的定义如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span> 属性规定元素的哪一侧不允许其他浮动元素。</span><br></pre></td></tr></table></figure></p>
<p>当然，这样看，还是很难理解为什么clear能清除浮动并撑开父元素高度。那我们举个栗子！<br>当先声明一个元素A向左浮动时，由于脱离文档流，这个元素的右边就会空出一片空间，空间的长宽与浮动元素长宽相同。<br>然后我们再声明另外一个元素B，如果元素A右侧空出的空间内，还能放下元素B的话，那么元素B就会自动补上去。<br>下面我写一个demo，应该就很好理解了。<br>HTML部分如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm divA<span class="tag">&lt;/<span class="name">p</span>&gt;</span> //此处用p</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I'm divB<span class="tag">&lt;/<span class="name">span</span>&gt;</span> //用span，防止两个都是p，不能展现父元素塌陷效果。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CSS部分如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#div &#123;</span><br><span class="line">  border:5px solid red;</span><br><span class="line">  width:400px;</span><br><span class="line">&#125;</span><br><span class="line">#a &#123;</span><br><span class="line">  background:rgba(149, 149, 149, 0.42); // 为了方便演示，A的背景色设置成半透明。</span><br><span class="line">  width:200px;</span><br><span class="line">  float: left;</span><br><span class="line">&#125;</span><br><span class="line">#b &#123;</span><br><span class="line">  background: #6EEBC1;</span><br><span class="line">  width:300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果图长这样：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float9.png" alt="demo效果"></p>
<p>从图上可以看到，元素B的一部分是在元素A空出的空间内的。并且I’m divB这句话在元素A的右侧。且父元素高度塌陷，父元素现在的高度就是元素B的高度。<br>那么如果元素A右侧空出的空间内，放不下元素B呢？<br>我们把元素B宽度调整为200px。</p>
<p><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float10.png" alt="放不下时的效果"><br>可以看出，元素B就自成一行了。</p>
<p>给元素B加入<code>clear:both</code>后，元素B将忽略左边浮动所产生的空间，不去补空缺。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/float11.png" alt="元素B设置clear:both后"><br>如图所示，元素B会另起一行。而不是缩到浮动产生的空间内。</p>
<h3 id="撑开父元素空间的奥秘"><a href="#撑开父元素空间的奥秘" class="headerlink" title="撑开父元素空间的奥秘"></a>撑开父元素空间的奥秘</h3><p>在w3school中，clear的定义中还有这么一句话：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“在 <span class="selector-tag">CSS2</span><span class="selector-class">.1</span> 中，会在设置清除浮动的元素上外边距之上增加清除空间，而外边距本身并不改变。”</span><br></pre></td></tr></table></figure></p>
<p>也就是说，<strong><em>因为浮动而产生的空白空间，会被填充为实际存在的空间。</em></strong>。那么，自然就能撑开父元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结下来，浮动与清除浮动的顺序关系如下：</p>
<ol>
<li>设置元素A浮动，元素脱离文档流，不计算高度。父元素出现高度塌陷。</li>
<li>浮动元素A产生空白空间。空间长宽等于元素A的长宽。后面元素会自动补空缺。</li>
<li>给浮动元素之后的元素B设置<code>clear:both</code>，元素B将不去补空缺。</li>
<li>元素B不仅不补空缺，还会把元素A因浮动而产生的空白空间填充为实际空间。</li>
<li>实际空间被计算高度，父元素被撑开。</li>
</ol>
<p>这么一番走下来，花了很多时间去思考，去写demo。但对CSS浮动的理解也加深了。浮动为何引起父元素塌陷和清除浮动为何能撑开父元素这两个问题，一直是我的盲点。所以这次寒假，集中了两天时间去攻克它（除夕和正月初一，大过年的写代码，感觉有点怪但效率却出奇的高……）。</p>
<p>参考链接：</p>
<blockquote>
<p><a href="http://www.imooc.com/view/121" target="_blank" rel="external">《CSS深入理解之float浮动》– 张鑫旭（也是课程地址）</a><br><a href="http://www.w3school.com.cn/cssref/pr_class_clear.asp" target="_blank" rel="external">CSS clear 属性</a><br><a href="http://zhihu.com/question/25520512/answer/39121180?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu" target="_blank" rel="external">clear:both 为什么不起作用？–知乎，田雅文的回答</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-《计算机科学导论》读书笔记（一）：浅析面向过程与面向对象编程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/05/《计算机科学导论》读书笔记（一）：浅析面向过程与面向对象编程/" class="article-date">
  	<time datetime="2016-02-05T04:06:41.000Z" itemprop="datePublished">2016-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/05/《计算机科学导论》读书笔记（一）：浅析面向过程与面向对象编程/">《计算机科学导论》读书笔记（一）：浅析面向过程与面向对象编程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="《计算机科学导论》的来源"><a href="#《计算机科学导论》的来源" class="headerlink" title="《计算机科学导论》的来源"></a>《计算机科学导论》的来源</h2><p>仍记得那是15年的5月底，面临着毕业的学长学姐看着自己大学四年的诸多书籍，纷纷在校内开始了摆摊生活。当时才大一的我，看着一长条的书摊，仿佛看到了宝藏。才逛了一会儿，我心满意足的抱着好几本书回寝室了。其中就包括这两天看到入迷的《计算机科学导论》。</p>
<p>当初买下它的时候，只是模糊的觉得，自己可能会用到。既然又是书，所以就爽快的买了下来。反正也才5元（逃）。回去一翻开，更是惊喜，书如全新的一般，连名字都没有。然后……放在书柜上，就束之高阁了。直到寒假回家时，顺手把它带回了家。</p>
<p>就是下图的这本书。</p>
<p><img src="http://7xoxxe.com1.z0.glb.clouddn.com/jkdl.png" alt="计算机科学导论"></p>
<p>结果昨天下午看了一眼，便一发不可收拾，一口气读到深夜两点。读完之后，感觉之前所有零散的知识点被串成了一串，有种拨云见月的感觉。之前很多无法理解的概念，也都迎刃而解了。</p>
<p>看来无论是学习社会科学或计算机科学，都如杨绛先生所说的那句话一样：</p>
<blockquote>
<p>“你的问题主要在于读书不多而想得太多。”</p>
</blockquote>
<p>或者又如《荀子》一书中劝学篇所言：</p>
<blockquote>
<p>“吾尝终日而思矣，不如须臾之所学也；吾尝跂而望矣，不如登高之博见也。” </p>
</blockquote>
<p>总而言之，万分庆幸自己回家时候带了这本《计算机专业导论》，让我领略到计算机科学的万千精彩。</p>
<h2 id="关于面向过程与面向对象的疑惑"><a href="#关于面向过程与面向对象的疑惑" class="headerlink" title="关于面向过程与面向对象的疑惑"></a>关于面向过程与面向对象的疑惑</h2><p>第一次学编程时，学习的是C语言。在刚开始学的时候，就知道C语言是一门面向过程的编程语言，除此之外还有面向对象的编程语言。当时的我，并没有想这么多。只是慢慢的看视频然后学习。</p>
<p>面向过程与面向对象是学编程过程中不可避免的问题。果然，这个问题在15年3月份，我学习Java后开始出现了。</p>
<p>当时在图书馆借阅了李刚老师的《疯狂Java 第二版》，在学习到面向对象部分，彻底晕头转向了。究竟什么是面向对象，什么又是面向过程？为什么说面向对象是一种良好编程方法？封装、继承、多态到底是什么？（这应该算自己第一次尝到计算机基础不牢的苦果，只是当时没有意识到）。</p>
<p>在15年6月学前端，到现在已有大半年。期间也看过诸如《JavaScript面向对象编程》等书，也去谷歌过相关文档。但总感觉似懂非懂。</p>
<p>还好，我碰见了《计算机专业导论》这本书，一本让我有“拨云见月”之感的书。</p>
<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>在这儿，我们先介绍面向过程。<br>在面向过程的程序中，我们把程序看成是 <code>操纵被动对象的活动主体</code>。其中，被动对象本身不能开始一个动作，但能从活动主体（程序）接收动作。<br>被动对象的数据储存在内存中，程序为了操纵它们，会发布动作。称之<code>过程</code>。</p>
<p>例如打印一个文件，文件就是被动对象。同时为了能被打印，文件会存储在内存中。而程序为了打印文件，会调用一个print过程，print过程中包含了计算机打印所需的步骤。</p>
<p>在过程式模式中，对象（文件）和过程（打印）是完全分开的实体。对象（文件）是能接收print动作的实体。而过程print是被编写的一个独立的实体，程序只是触发它。</p>
<p>看到上面这一大串，是不是有点晕了？简单来说，面向过程模式的程序由三部分组成：</p>
<ol>
<li>对象创建部分</li>
<li>一组过程调用</li>
<li>每个过程的一组代码</li>
</ol>
<p>结合上面的例子，这样就比较好理解了。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象模式与面向过程模式区别在于：面向对象模式处理活动对象，而非被动对象。如日常生活中的洗衣机，汽车等。 <em>在这些对象上执行的动作都包含在这些对象中</em>，对象只需要接收合适的外部刺激即可。</p>
<p>还是拿打印文件做例子，在面向对象模式中的文件能把所有被文件执行的过程（面向对象中成为方法）（打印，复制粘贴等）打包在一起。在这种模式下，程序只需要向文件发出打印或者复制的请求，文件就会被打印或复制。而这些方法，也被从这些对象继承的其它对象共享。<br>比较面向过程与面向对象，可以看出面向过程编程中的过程是独立的实体，但面向对象模式中的方法是属于对象的。</p>
<p>面向对象的核心要点，在于类。因为相同类型的对象需要一组方法，为了创建这些方法，C++或者Java都选择使用成为类的单元。</p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>在面向对象模式中，作为本质，一个对象能从另外一个对象继承。这个概念称为<code>继承性</code>。例如，当一个几何形状类被定义后，我们就可以定义矩形类。矩形是拥有额外特性的几何形状。</p>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>面向对象的多态性是指我们可以定义一些具有相同名字操作的方法，但这些操作在不同类中会产生不同结果。<br>例如我们给几何图形类定义一个算面积的方法，同时定义圆形类和方形类继承几何图形类。那么同样是算面积，圆形类的结果和方形类的结果会不一样。因为两者计算公式不一样。<br>这就是多态。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>本以为只是简单的描述一下自己对面向过程和面向对象的理解。结果写的时候却是磕磕绊绊。看来和老师说的一样，自己学的好和教别人教的好是两回事。还是得努力去加强这一方面。</p>
<p>接下来可能会写好几篇《计算机专业导论》的读书笔记，因为解决了我颇多难点，所以算是值得一写。至于看的速度，我觉得算是较快的，因为计算机系统组成，计算机网络，算法等章节，我在之前就有过专门学习。只是没有一本书把知识点给串起来而已。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-计科之路--Start!" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/03/计科之路--Start!/" class="article-date">
  	<time datetime="2016-02-03T12:29:02.000Z" itemprop="datePublished">2016-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/03/计科之路--Start!/">计科之路--Start!</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>按照之前的学习进度表，现在的我应该在钻研CSS的float等属性。但是我在这两天却选择了读一本书。<br>书的全名是：《如何高效学习：1年完成MIT4年33门课程的整体性学习法》<br>就是下面图片这本：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/read.jpg" alt="《如何高效学习》"><br>哈哈，看到这名字，是不是很像鸡汤？<br>曾经的我也是这么认为的。<br>我第一次接触到这本书时，是在大一下学期，也就是大约一年前。当初看这本书的初衷，只是因为名字听起来很流弊，学习后能功力大涨的样子。（心态大概和学习闭包一样，以为学习后便能习得不世神功，称霸武林。）<br>但是当时年轻气躁，这本书只翻了两页，便觉得不适合自己，学习还是得一板一眼的学等等。这本书就放在书架上吃灰了。</p>
<h2 id="计科之路"><a href="#计科之路" class="headerlink" title="计科之路"></a>计科之路</h2><p>白驹过隙，不知不觉已是一年。过年回家时，捎上了《JavaScript设计模式》、《数学与生活》与这本书。因为虽然人还是那个人，但是体验和感悟已经完全不一样了。<br>一年前的我，还在思考要考研还是考公务员。那时候对于编程，只是觉得很新奇而已。<br>一年后的我，不在思考考研或是公务员，而是一心想着编程，想着怎么让代码写的更漂亮，怎么让代码跑的更快。<br>但一个很严峻的问题也摆在我的眼前。那就是我的计算机基础怎么办？<br>虽然一直有人说前端不需要啥基础，但是我依然坚信并践行着那句话：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“编程中，业务能力决定下限，而计算机基础决定其上限。”</span><br></pre></td></tr></table></figure></p>
<p>这句话给我的感觉，就像这学期《领导科学》课程中老师所说的“天花板现象”一样。只是“天花板现象”的原因有天然的和人为的之分。但是计算机基础的学习，人为因素占了绝大部分。同时也是因为热爱，决定开始从零开始学计算机基础。<br>嗯……其实也不算从0开始学，之前自己也有学过一些计算机科学的课程。比如我的选修课《计算机网络》，在Coursea上了一半的《计算机系统》，自学的《学习JavaScript数据结构与算法》（逃）等。<br>不过一直觉得知识学的过于零散，然后想系统学习一番。</p>
<p>于是轻车熟路的找到了网易云课堂的大学计算机专业体系：<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/ykt.png" alt="网易云课堂的大学计算机专业体系"></p>
<p>决定按知识路线图，彻底给自己补一补基础。</p>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>当然，前端的学习也不会落下。因为两者不会冲突，前端的学习与应用，在一定程度上是对所学的计算机技术的实践。</p>
<p>而且点开网易云课堂计算机体系的大一课程时，惊喜的发现计算机专业导论课所学习的内容，自己从前两年就有过接触，上个学期更是在Coursea有过专门的学习。只是名称不一致罢了。</p>
<p>看来课业会轻松很多，这两年的兴趣式上课，还是帮助了我非常多的。<br>无论是人文社科的经史哲政，或者是理工科的计算机、医学常识等。都切实的让我了解到另一个世界，一个文科生从未见过的理科世界。</p>
<p>前端路漫漫，且行且歌。<br>（本篇博客略凌乱，因为写这篇文章的两天，发生了很多事情，心境变化较大。所以前后对接会有些不协调。）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(7)——学习JavaScript之this,call,apply" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/28/寒假前端学习/寒假前端学习(7)——学习JavaScript之this,call,apply/" class="article-date">
  	<time datetime="2016-01-28T05:47:37.000Z" itemprop="datePublished">2016-01-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/28/寒假前端学习/寒假前端学习(7)——学习JavaScript之this,call,apply/">寒假前端学习(7)——学习JavaScript之this,call,apply</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习起因："><a href="#学习起因：" class="headerlink" title="学习起因："></a>学习起因：</h2><p>在之前的JavaScript学习中，this,call,apply总是让我感到迷惑，但是他们的运用又非常的广泛。遂专门花了一天，来弄懂JavaScript的this,call,apply。<br>中途参考的书籍也很多，以《JavaScript设计模式与开发实践》为主，《JavaScript高级程序设计》、《你不知道的JavaScript》为辅。这三本书对我理解this,call,apply都起了很大的帮助。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>首先，我们先讲述this。</p>
<p>在《JavaScript设计模式与开发实践》关于this的描述中，我认为有一句话切中了this的核心要点。那就是：</p>
<blockquote>
<p><strong>JavaScript的this总是指向一个对象</strong></p>
</blockquote>
<p>具体到实际应用中，this的指向又可以分为以下四种：</p>
<ol>
<li>作为对象的方法调用</li>
<li>作为普通函数调用</li>
<li>构造器调用</li>
<li>apply和call调用</li>
</ol>
<p>接下来我们去剖析前3点，至于第4点的apply和call调用，会在call和apply部分详细讲解。</p>
<h3 id="1-作为对象的方法调用"><a href="#1-作为对象的方法调用" class="headerlink" title="1.作为对象的方法调用"></a>1.作为对象的方法调用</h3><p>说明：作为对象方法调用时，this指向该对象。<br>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 1.作为对象的方法调用</span><br><span class="line"> *</span><br><span class="line"> * 作为对象方法调用时，this指向该对象。</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  getA: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.getA(); <span class="comment">// true , 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-作为普通函数调用"><a href="#2-作为普通函数调用" class="headerlink" title="2.作为普通函数调用"></a>2.作为普通函数调用</h3><p>说明：作为普通函数调用时，this总是指向全局对象(浏览器中是window)。<br>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 2.作为普通函数调用</span><br><span class="line"> *</span><br><span class="line"> * 不作为对象属性调用时,this必须指向一个对象。那就是全局对象。</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'globalName'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getName(); <span class="comment">// 'globalName'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  name: <span class="string">"ObjectName"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.getName(); <span class="comment">// 'ObjectName'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里实质上是把function() &#123;console.log(this.name)&#125;</span></span><br><span class="line"><span class="comment">// 这句话赋值给了theName。thisName在全局对象中调用，自然读取的是全局对象的name值</span></span><br><span class="line"><span class="keyword">var</span> theName = myObject.getName;</span><br><span class="line"></span><br><span class="line">theName(); <span class="comment">// 'globalName'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-构造器调用"><a href="#3-构造器调用" class="headerlink" title="3.构造器调用"></a>3.构造器调用</h3><p>说明：作为构造器调用时，this指向返回的这个对象。<br>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 3.作为构造器调用</span><br><span class="line"> * </span><br><span class="line"> * 作为构造器调用时，this指向返回的这个对象。</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Lxxyx"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> myClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// Lxxyx</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// myClass &#123;name: "Lxxyx"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>但是如果构造函数中手动指定了return其它对象，那么this将不起作用。<br>如果return的是别的数据类型，则没有问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Lxxyx"</span>;</span><br><span class="line">  <span class="comment">// 加入return时，则返回的是别的对象。this不起作用。</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name:<span class="string">"ReturnOthers"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> myClass();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// ReturnOthers</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Call和Apply"><a href="#Call和Apply" class="headerlink" title="Call和Apply"></a>Call和Apply</h3><p>Call和Apply的用途一样。都是用来指定函数体内this的指向。</p>
<h3 id="Call和Apply的区别"><a href="#Call和Apply的区别" class="headerlink" title="Call和Apply的区别"></a>Call和Apply的区别</h3><p>Call：第一个参数为this的指向，要传给函数的参数得一个一个的输入。<br>Apply：第一个参数为this的指向，第二个参数为数组，一次性把所有参数传入。</p>
<p>如果第一个参数为null,则this指向宿主环境，浏览器中是window。</p>
<h3 id="1-改变this指向"><a href="#1-改变this指向" class="headerlink" title="1.改变this指向"></a>1.改变this指向</h3><p>说明：这是call和apply最常用的用途了。用于改变函数体内this的指向。<br>举例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"GlobalName"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func(); <span class="comment">// "GlobalName"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Lxxyx"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.getName.apply(<span class="built_in">window</span>) <span class="comment">// "GlobalName" 将this指向window</span></span><br><span class="line">func.apply(obj) <span class="comment">// "Lxxyx" 将this指向obj</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-借用其它对象的方法"><a href="#2-借用其它对象的方法" class="headerlink" title="2.借用其它对象的方法"></a>2.借用其它对象的方法</h3><p>这儿，我们先以一个立即执行匿名函数做开头：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// 1,2</span></span><br><span class="line">  <span class="comment">// 调用Array的原型方法</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>) <span class="comment">// 1,2,3</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>函数具有arguments属性，而arguments是一个类数组。<br>但是arguments是不能直接调用数组的方法的，所以我们要用call或者apply来调用Array对象的原型方法。<br>原理也很容易理解，比如刚才调用的是push方法，而push方法在谷歌的v8引擎中，源代码是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayPush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = TO_UINT32(<span class="keyword">this</span>.length); <span class="comment">// 被push对象的长度</span></span><br><span class="line">  <span class="keyword">var</span> m = % _ArgumentsLength(); <span class="comment">// push的参数个数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">this</span>[i + n] = % _Arguments(i); <span class="comment">// 复制元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.length = n + m; <span class="comment">//修正length属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他只与this有关，所以只要是类数组对象，都可以调用相关方法去处理。</p>
<p>这部分内容比较复杂，再加上自己水平也不太够。所以推荐有条件的同学去购买相关书籍，或者等我的后续博客文章。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>通过对这部分的学习，算是加深了对JavaScript的理解。最直观的表现就是，去看一些优秀框架的源代码时，不再是被this,call,apply,bind绕的晕乎乎的。还是很开心的~</p>
<p>下一段时间，准备深入探索一下日常学习和使用的CSS。毕竟JavaScript学了，HTML和CSS也不能落下。</p>
<p>前端路漫漫，且行且歌。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-迁移至Ubuntu的折腾之旅" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/27/迁移至Ubuntu的折腾之旅/" class="article-date">
  	<time datetime="2016-01-27T10:33:04.000Z" itemprop="datePublished">2016-01-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/27/迁移至Ubuntu的折腾之旅/">迁移至Ubuntu的折腾之旅</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前因"><a href="#前因" class="headerlink" title="前因"></a>前因</h2><p>之前一直有装Win10和Deepin的双系统，本打算装了Deepin15后，就安心的在Linux下学习和工作。<br>但无奈的是，Deepin15基于Debian而非Ubuntu，所以为了装一个shadowsocks的Gui客户端，还得专门去编译。这也就算了，在装上SS后，又安装了Sublime，但Sublime在Linux下有不能输入中文的BUG。 这个问题算是致命问题了，因为我平常90%的开发，都只使用Sublime Text。<br>于是去找解决方法。一番谷歌之下，告诉我得去新建个c文件啥的。或者去Github上使用一键包。<br>我当然用一键包啊，于是很开心的打开了修复包的Github地址，开头第一句话就让我懵逼了。<br><code>There still some problems with Debian.</code><br>翻译成中文就是：“Debian用户还是洗洗睡吧。”<br>再加上Deepin15桌面经常会冒出别的文件夹的新文件，于是心灰意冷的我，开始继续使用Windows做开发。 </p>
<h2 id="向Ubuntu转移"><a href="#向Ubuntu转移" class="headerlink" title="向Ubuntu转移"></a>向Ubuntu转移</h2><p>本来Windows用的也还可以，但是由于自身CPU性能跟不太上(i5-4200u)，用webpack编译个文件要花上40多秒，运行过程中也各种降频，简直不能忍。于是决定上Liunx，同时又因为有Deepin的前车之鉴，所以决定上Ubuntu Kylin。<br>嗯，不是Ubuntu，是中国的麒麟版。原因很简单：壁纸好看+内置Chrome和搜狗输入法。 于是在折腾中，开始了Ubuntu Kylin的安装。</p>
<h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>安装过程倒是稀疏平常，一路next就开始了安装。安装速度很快。不一会儿就提示我安装完成了。<br>至于分区，当然是用Ubuntu安装界面的一键分区啦。（逃） 配置过程就一帆风顺的多了。</p>
<p>开机，安装更新，git和Shadowsocks，然后就是安装oh-my-zsh。</p>
<p>装上新款的oh-my-zsh后，继续安装nvm用于管理node版本。如果先装nvm再装zsh的话，zsh启动时会读取不到nvm。虽然可以自己去配置文件改，但终究比较麻烦。 接下来用nvm安装node 5.5（版本号更新的好快……），安装国内源的cnpm。也都一下子就过去了。</p>
<p>最难配置的地方，还是在Sublime，下了修复文件修复Sublime不能输入中文的问题后，发现只有在命令行输入<code>subl</code>才能启动输入中文的Sublime,于是又深入<code>/usr/share/applications</code>去修改<code>sublime_text.desktop</code>，把<code>exec</code>改为<code>subl</code>。顺带还在<code>default.list</code>中把默认编辑软件从gedit换成了Sublime。于是耗时好几个小时的Ubuntu，终于完成了。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>果然做开发，还是Linux好，不说别的。感觉Linux的幺蛾子比windows要少上很多。用的时候也没用怎么卡顿，编译速度超过windows n+1倍。 不管咋样，寒假就靠ubuntu过啦～</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/19/寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树/" class="article-date">
  	<time datetime="2016-01-19T09:58:57.000Z" itemprop="datePublished">2016-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/19/寒假前端学习/寒假前端学习(6)——学习JavaScript数据结构与算法：二叉搜索树/">寒假前端学习(6)——学习JavaScript数据结构与算法（四）：二叉搜索树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本系列的第一篇文章: <a href="http://t.cn/R4Ybrs0" target="_blank" rel="external">学习JavaScript数据结构与算法（一）：栈与队列</a><br>第二篇文章：<a href="http://t.cn/R4W3y3X" target="_blank" rel="external">学习JavaScript数据结构与算法（二）：链表</a><br>第三篇文章: <a href="http://t.cn/R4jLf0o" target="_blank" rel="external">学习JavaScript数据结构与算法（三）：集合</a><br>第四篇文章: <a href="http://t.cn/R4QbVOg" target="_blank" rel="external">学习JavaScript数据结构与算法（四）：二叉搜索树</a></p>
</blockquote>
<h2 id="我与二叉树的前尘往事"><a href="#我与二叉树的前尘往事" class="headerlink" title="我与二叉树的前尘往事"></a>我与二叉树的前尘往事</h2><p>在刚学编程时，就知道有一种数据结构叫“树”，树中的翘楚是“二叉树”，“红黑树”等。<br>据说“树”构在编程界呼风唤雨无所不能。让无数程序员闻风丧胆。甚至在面试时，更是有“手写二叉树”，“翻转二叉树”等题目坐镇。</p>
<p>好吧，我承认这些在当时都把我吓住了。</p>
<p>但是当我颤抖着打开《学习JavaScript数据结构与算法》，开始敲下关于“树”的代码时，突然觉得，好像也没有那么难呢。<br>于是心怀激动，一口气敲完了书上的例子，中途也思考了很久，不断的在纸上演算等。但总的来说，还是学的很开心的。</p>
<h2 id="树の简介"><a href="#树の简介" class="headerlink" title="树の简介"></a>树の简介</h2><p>之前学的栈、队列、链表等数据结构，都是顺序数据结构。而树，将会是我们学的第一种非顺序数据结构。</p>
<p>放在现实里呢，有个很生动的例子，公司组织架构图。长这样:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/tree1.png" alt="公司组织架构图"></p>
<p>而我们要学的树，长这样:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/tree.png" alt="树の图示"></p>
<h3 id="节点简介"><a href="#节点简介" class="headerlink" title="节点简介"></a>节点简介</h3><p>其中，树中的每个元素，都叫做<code>节点</code>。从节点延伸而下的，叫<code>子节点</code>。<br>树顶部的节点叫根节点。每棵树只有一个根节点。（图中15就是根节点）<br>在节点中，有子节点的节点也称为内部节点，没有的话则被称为外部节点或者叶节点。<br>同时在节点中是有祖先和后代关系的，比如节点9的祖先就有13,7,6,15四个。</p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><p>深度: 节点的深度取决于其祖先的数量，节点9的深度就是4。<br>树的高度，树的高度体现为节点深度的最大值。<br>比如上图，节点深度最大值为4，则树的高度为4。</p>
<h3 id="二叉树与二叉搜索树"><a href="#二叉树与二叉搜索树" class="headerlink" title="二叉树与二叉搜索树"></a>二叉树与二叉搜索树</h3><p>二叉树的最大特点就在于，它的节点最多只有两个子节点:左侧子节点和右侧子节点。<br>二叉搜索树则是二叉树的一种，但它只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。<br>像刚才的这幅图，就是二叉搜索树。<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/tree.png" alt="二叉搜索树"></p>
<p>而我们本文要学习的内容，就是如何写一个二叉搜索树。</p>
<h3 id="JavaScipt中二叉搜索树的实现"><a href="#JavaScipt中二叉搜索树的实现" class="headerlink" title="JavaScipt中二叉搜索树的实现"></a>JavaScipt中二叉搜索树的实现</h3><p>首先，创建一个构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 二叉搜索树的构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearchTree</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 二叉搜索树键的构造函数</span><br><span class="line">   * @param &#123;Number&#125; key 要生成的键值</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 键值</span></span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 二叉树的根节点，不存在时表示为Null</span><br><span class="line">   * @type &#123;Null or Number&#125;</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> root = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在之前提到过的双向链表中，每个节点包含两个指针，一个指向左侧节点，一个指向右侧节点。在二叉搜索树中，每个节点也有两个指针，一个指向左侧子节点，一个指向右侧子节点。但在二叉搜索树中，我们把节点成为<code>键</code>，这是术语。</p>
<p>二叉搜索树需要有如下的方法:</p>
<ul>
<li>insert(key): 向树中插入一个新的键</li>
<li>inOrderTraverse(): 通过中序遍历方式，遍历所有节点</li>
<li>preOrderTranverse(): 通过先序遍历方式，遍历所有节点</li>
<li>postOrderTranverse(): 通过后序遍历方式，遍历所有节点</li>
<li>min(): 返回树中最小的值</li>
<li>max(): 返回树中最大的值</li>
<li>search(key): 搜索某个值，在树中则返回true</li>
<li>remove(key): 从树中移除某个键</li>
</ul>
<p>二叉搜索树的实现，基本都与递归有关（对我来说递归很绕，花了很久才理解）。如果不清楚递归相关概念，可以看看下面的参考链接。</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/20507130" target="_blank" rel="external">什么是递归</a></p>
</blockquote>
<h4 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法:"></a>insert方法:</h4><p>说明:向树中插入一个新的键<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插入某个键到二叉树中</span><br><span class="line"> * @param  &#123;Number&#125; key 要插入的键值</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用传入的值生成二叉树的键</span></span><br><span class="line">  <span class="keyword">var</span> newNode = <span class="keyword">new</span> Node(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根节点为Null时，传入的键则为根节点</span></span><br><span class="line">  <span class="comment">// 否则调用insertNode函数来插入子节点</span></span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">    root = newNode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    insertNode(root, newNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 用于插入子节点。</span><br><span class="line"> * @param  &#123;Node&#125; node    根节点</span><br><span class="line"> * @param  &#123;Node&#125; newNode 要插入的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> insertNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//由于二叉搜索树的性质，所以当键值小于当前所在节点的键值</span></span><br><span class="line">  <span class="comment">//则使得左子结点成为新的要比较的节点，进行递归调用</span></span><br><span class="line">  <span class="comment">//如果左子结点为null，则将键值赋值给左子结点。</span></span><br><span class="line">  <span class="comment">//如果键值大于当前所在节点的键值，原理同上。</span></span><br><span class="line">  <span class="keyword">if</span> (newNode.key &lt; node.key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.left = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      insertNode(node.left, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node.right = newNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      insertNode(node.right, newNode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="inOrderTraverse方法"><a href="#inOrderTraverse方法" class="headerlink" title="inOrderTraverse方法:"></a>inOrderTraverse方法:</h4><p>说明:通过中序遍历方式，遍历所有节点<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 中序遍历操作，常用于排序。会把树中元素从小到大的打印出来。</span><br><span class="line"> * 因为在javascript的递归中，遇到递归是，会优先调用递归的函数。直到递归不再进行。</span><br><span class="line"> * 然后会在递归调用的最后一个函数中执行其它语句。再一层层的升上去。</span><br><span class="line"> * 所以中序遍历会有从小到大的输出结果。</span><br><span class="line"> * 后续的先序和后续遍历和这个原理差不多，取决于callback放在哪儿。</span><br><span class="line"> * </span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.inOrderTraverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  inOrderTraverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 中序遍历的辅助函数，用于遍历节点</span><br><span class="line"> * @param  &#123;Node&#125;   node     遍历开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> * @return &#123;[type]&#125;            [description]</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> inOrderTraverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前节点不为NULL则继续递归调用</span></span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    inOrderTraverseNode(node.left, callback);</span><br><span class="line">    <span class="comment">// 获取到节点后，调用的函数</span></span><br><span class="line">    callback(node.key);</span><br><span class="line">    inOrderTraverseNode(node.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>假如我们这儿加入打印节点值的函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> printNode = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inOrderTraverse(printNode) <span class="comment">// 输出排序后树的值</span></span><br></pre></td></tr></table></figure></p>
<h4 id="preOrderTranverse方法"><a href="#preOrderTranverse方法" class="headerlink" title="preOrderTranverse方法:"></a>preOrderTranverse方法:</h4><p>说明:通过先序遍历方式，遍历所有节点<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 前序遍历操作，常用于打印一个结构化的文档</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.preOrderTranverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  preOrderTranverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 前序遍历的辅助函数，用于遍历节点</span><br><span class="line"> * @param  &#123;Node&#125;   node     遍历开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> preOrderTranverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">    callback(node.key);</span><br><span class="line">    preOrderTranverseNode(node.left, callback);</span><br><span class="line">    preOrderTranverseNode(node.right, callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="postOrderTranverse方法"><a href="#postOrderTranverse方法" class="headerlink" title="postOrderTranverse方法:"></a>postOrderTranverse方法:</h4><p>说明:通过后序遍历方式，遍历所有节点<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 后序遍历操作，常用于计算所占空间</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.postOrderTranverse = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  postOrderTranverseNode(root, callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 后序遍历的辅助函数，用于遍历节点</span><br><span class="line"> * @param  &#123;Node&#125;   node     遍历开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Function&#125; callback 获取到节点后的回调函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> postOrderTranverseNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  postOrderTranverseNode(node.left, callback);</span><br><span class="line">  postOrderTranverseNode(node.right, callback);</span><br><span class="line">  callback(node.key);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="min方法"><a href="#min方法" class="headerlink" title="min方法:"></a>min方法:</h4><p>说明:返回树中最小的值，由二叉搜索树的性质易知，最左侧的为最小值。则只需取得最左侧的值即可。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回树中最小的值</span><br><span class="line"> * @return &#123;Function&#125; min函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.min = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> minNode(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * min函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 查找开始的节点，默认为root</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> minNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果node存在，则开始搜索。能避免树的根节点为Null的情况</span></span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。</span></span><br><span class="line">    <span class="comment">// 若左子节点为null，则该节点肯定为最小值。</span></span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="max方法"><a href="#max方法" class="headerlink" title="max方法:"></a>max方法:</h4><p>说明:返回树中最大的值，由min函数易知，最大值在最右侧。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回树中最大的值</span><br><span class="line"> * @return &#123;Function&#125; max函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.max = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> maxNode(root);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * max函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 查找开始的节点，默认为root</span><br><span class="line"> * @return &#123;Key&#125;      节点的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> maxNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="search方法"><a href="#search方法" class="headerlink" title="search方法:"></a>search方法:</h4><p>说明: 搜索某个值，在树中则返回true<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 搜索某个值是否存在于树中</span><br><span class="line"> * @param  &#123;Node&#125; key 搜索开始的节点，默认为root</span><br><span class="line"> * @return &#123;Function&#125;     search函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.search = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> searchNode(root, key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * search函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 搜索开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Key&#125; key  要搜索的键值</span><br><span class="line"> * @return &#123;Boolean&#125;      找到节点则返回true，否则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> searchNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果根节点不存在，则直接返回null</span></span><br><span class="line">  <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">    searchNode(node.left, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">    searchNode(node.right, key)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果该节点值等于传入的值，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法:"></a>remove方法:</h4><p>说明:从树中移除某个键，要应对的场景:</p>
<ol>
<li>只是一个叶节点</li>
<li>有一个子节点</li>
<li>有两个子节点的节点<br>因为要应付不同的场景，所以这是最麻烦的方法了。让我思考了好久才理解。如果你觉得看不懂的话，可以下载源代码把这一段写一遍。<br>实现: <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 从树中移除某个键</span><br><span class="line"> * @param  &#123;Key&#125; key 要移除的键值</span><br><span class="line"> * @return &#123;Function&#125;     remove函数的辅助函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  root = removeNode(root, key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * remove函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 搜索开始的节点，默认为root</span><br><span class="line"> * @param  &#123;Key&#125; key   要移除的键值</span><br><span class="line"> * @return &#123;Boolean&#125;   移除成功则返回true，否则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNode = <span class="function"><span class="keyword">function</span>(<span class="params">node, key</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果根节点不存在，则直接返回null</span></span><br><span class="line">  <span class="keyword">if</span> (node === root) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 未找到节点前，继续递归调用。</span></span><br><span class="line">  <span class="keyword">if</span> (key &lt; node.key) &#123;</span><br><span class="line">    node.left = removeNode(node.left, key)</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node.key) &#123;</span><br><span class="line">    node.right = removeNode(node.right, key)</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一种场景：只是一个叶节点</span></span><br><span class="line">    <span class="comment">// 这种情况只需要直接把节点赋值为null即可</span></span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 处理完直接return节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二种场景：有一个子节点</span></span><br><span class="line">    <span class="comment">// 如果左节点为null，则代表右节点存在。</span></span><br><span class="line">    <span class="comment">// 于是把当前节点赋值为存在的那个子节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left === <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.right;</span><br><span class="line">      <span class="comment">// 处理完直接return节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">      <span class="comment">// 处理完直接return节点</span></span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第三种场景：有两个子节点</span></span><br><span class="line">    <span class="comment">// 首先加入辅助节点，同时找寻右子节点中的最小节点</span></span><br><span class="line">    <span class="comment">// 并把当前节点替换为右子节点中的最小节点</span></span><br><span class="line">    <span class="comment">// 同时为了避免节点重复，移除右子节点中的最小节点</span></span><br><span class="line">    <span class="keyword">var</span> aux = findMinNode(node.right);</span><br><span class="line">    node.key = aux.key;</span><br><span class="line"></span><br><span class="line">    node.right = removeNode(node.right, aux.key);</span><br><span class="line">    <span class="comment">// 处理完直接return节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * remove函数的辅助函数</span><br><span class="line"> * @param  &#123;Node&#125; node 查找开始的节点，默认为root</span><br><span class="line"> * @return &#123;Node&#125;      最小的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果node存在，则开始搜索。能避免树的根节点为Null的情况</span></span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 只要树的左侧子节点不为null，则把左子节点赋值给当前节点。</span></span><br><span class="line">    <span class="comment">// 若左子节点为null，则该节点肯定为最小值。</span></span><br><span class="line">    <span class="keyword">while</span> (node &amp;&amp; node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">      node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码:"></a>源代码:</h4><p>源代码在此~</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/BinarySearchTree.js" target="_blank" rel="external">二叉搜索树-源代码</a></p>
</blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>写文章的时候，人有点感冒，晕晕乎乎的。不过写完之后就好多了，脑子清醒了许多。<br>二叉树这一章，就我而言感慨万分，也算是暂时满足了自己对数据结构中“树”的向往与愿望，也不是之前看数据结构中那种迷茫的感觉。<br>能用JavaScript亲手实现，还是非常开心的。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(5)——学习JavaScript数据结构与算法：集合" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/16/寒假前端学习/寒假前端学习(5)——学习JavaScript数据结构与算法：集合/" class="article-date">
  	<time datetime="2016-01-16T01:47:33.000Z" itemprop="datePublished">2016-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/16/寒假前端学习/寒假前端学习(5)——学习JavaScript数据结构与算法：集合/">寒假前端学习(5)——学习JavaScript数据结构与算法（三）：集合</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本系列的第一篇文章: <a href="http://t.cn/R4Ybrs0" target="_blank" rel="external">学习JavaScript数据结构与算法（一）：栈与队列</a><br>第二篇文章：<a href="http://t.cn/R4W3y3X" target="_blank" rel="external">学习JavaScript数据结构与算法（二）：链表</a><br>第三篇文章: <a href="http://t.cn/R4jLf0o" target="_blank" rel="external">学习JavaScript数据结构与算法（三）：集合</a><br>第四篇文章: <a href="http://t.cn/R4QbVOg" target="_blank" rel="external">学习JavaScript数据结构与算法（四）：二叉搜索树</a></p>
</blockquote>
<h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合(Set)"></a>集合(Set)</h2><p>说起集合，就想起刚进高中时，数学第一课讲的就是集合。因此在学习集合这种数据结构时，倍感亲切。<br>集合的基本性质有一条: 集合中元素是不重复的。因为这种性质，所以我们选用了对象来作为集合的容器，而非数组。<br>虽然数组也能做到所有不重复，但终究过于繁琐，不如集合。</p>
<h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><p>集合的基本操作有交集、并集、差集等。这儿我们介绍JavaScipt集合中交集、并集、差集的实现。至于这三个的具体概念，可以看图:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/set.png" alt="交集、并集、差集"></p>
<h3 id="JavaScipt中集合的实现"><a href="#JavaScipt中集合的实现" class="headerlink" title="JavaScipt中集合的实现"></a>JavaScipt中集合的实现</h3><p>首先，创建一个构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 集合的构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set</span>方法 </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 集合元素的容器，以对象来表示</span><br><span class="line">   * @type &#123;Object&#125;</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> items = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>集合需要有如下方法:</p>
<ul>
<li>has(value): 检测集合内是否有某个元素</li>
<li>add(value): 给集合内添加某个元素</li>
<li>remove(value): 移除集合中某个元素</li>
<li>clear(value): 清空集合</li>
<li>size(): 返回集合长度</li>
<li>values(): 返回集合转换的数组</li>
<li>union(otherSet): 返回两个集合的并集</li>
<li>intersection(otherSet): 返回两个集合的交集</li>
<li>difference(otherSet): 返回两个集合的差集</li>
<li>subset(otherSet): 判断该集合是否为传入集合的子集</li>
</ul>
<h4 id="has方法"><a href="#has方法" class="headerlink" title="has方法:"></a>has方法:</h4><p>说明:集合中元素是不重复的。所以在其它任何操作前，必须用has方法确认集合是否有某个元素。这儿使用了hasOwnProperty方法来检测。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 检测集合内是否有某个元素</span><br><span class="line"> * @param  &#123;Any&#125;  value    要检测的元素</span><br><span class="line"> * @return &#123;Boolean&#125;       如果有，返回true</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.has = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// hasOwnProperty的问题在于</span></span><br><span class="line">  <span class="comment">// 它是一个方法，所以可能会被覆写</span></span><br><span class="line">  <span class="keyword">return</span> items.hasOwnProperty(value)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法:"></a>add方法:</h4><p>说明: 给集合内添加某个元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 给集合内添加某个元素</span><br><span class="line"> * @param &#123;Any&#125; value 要被添加的元素</span><br><span class="line"> * @return &#123;Boolean&#125;       添加成功返回True。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.add = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//先检测元素是否存在。</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value)) &#123;</span><br><span class="line">    items[value] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果元素已存在则返回false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法:"></a>remove方法:</h4><p>说明: 移除集合中某个元素<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 移除集合中某个元素</span><br><span class="line"> * @param  &#123;Any&#125; value 要移除的元素</span><br><span class="line"> * @return &#123;Boolean&#125;       移除成功返回True。</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//先检测元素是否存在。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.has(value)) &#123;</span><br><span class="line">    <span class="keyword">delete</span> items[value];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果元素不存在，则删除失败返回false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>####clear方法:<br>说明: 清空集合<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空集合</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.items = &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><p>说明: 返回集合长度，这儿有两种方法。第一种方法使用了Object.keys这个Api，但只支持IE9及以上。第二种则适用于所有浏览器。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回集合长度，只可用于IE9及以上</span><br><span class="line"> * @return &#123;Number&#125; 集合长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Object.keys方法能将对象转化为数组</span></span><br><span class="line">  <span class="comment">// 只可用于IE9及以上，但很方便</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回集合长度，可用于所有浏览器</span><br><span class="line"> * @return &#123;Number&#125; 集合长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.sizeLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> items) &#123;</span><br><span class="line">    <span class="keyword">if</span> (items.hasOwnProperty(prop)) &#123;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="values方法"><a href="#values方法" class="headerlink" title="values方法"></a>values方法</h4><p>说明: 返回集合转换的数组，这儿也有两种方法。理由同上。使用了Object.keys，只能支持IE9及以上。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回集合转换的数组，只可用于IE9及以上</span><br><span class="line"> * @return &#123;Array&#125; 转换后的数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.values = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(items);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回集合转换的数组，可用于所有浏览器</span><br><span class="line"> * @return &#123;Array&#125; 转换后的数组</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.valuesLegacy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> keys = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> items) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> keys;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="union方法"><a href="#union方法" class="headerlink" title="union方法"></a>union方法</h4><p>说明: 返回两个集合的并集<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回两个集合的并集</span><br><span class="line"> * @param  &#123;Set&#125; otherSet 要进行并集操作的集合</span><br><span class="line"> * @return &#123;Set&#125;          两个集合的并集</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.union = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化一个新集合，用于表示并集。</span></span><br><span class="line">  <span class="keyword">var</span> unionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">//将当前集合转换为数组，并依次添加进unionSet</span></span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    unionSet.add(values[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将其它集合转换为数组，依次添加进unionSet。</span></span><br><span class="line">  <span class="comment">//循环中的add方法保证了不会有重复元素的出现</span></span><br><span class="line">  values = otherSet.values();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">    unionSet.add(values[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> unionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="intersection方法"><a href="#intersection方法" class="headerlink" title="intersection方法"></a>intersection方法</h4><p>说明: 返回两个集合的交集<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回两个集合的交集</span><br><span class="line"> * @param  &#123;Set&#125; otherSet 要进行交集操作的集合</span><br><span class="line"> * @return &#123;Set&#125;          两个集合的交集</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.intersection = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化一个新集合，用于表示交集。</span></span><br><span class="line">  <span class="keyword">var</span> interSectionSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">//将当前集合转换为数组</span></span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">  <span class="comment">//遍历数组，如果另外一个集合也有该元素，则interSectionSet加入该元素。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (otherSet.has(values[i])) &#123;</span><br><span class="line">      interSectionSet.add(values[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> interSectionSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="difference方法"><a href="#difference方法" class="headerlink" title="difference方法"></a>difference方法</h4><p>说明: 返回两个集合的差集<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回两个集合的差集</span><br><span class="line"> * @param  &#123;Set&#125; otherSet 要进行差集操作的集合</span><br><span class="line"> * @return &#123;Set&#125;          两个集合的差集</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.difference = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//初始化一个新集合，用于表示差集。</span></span><br><span class="line">  <span class="keyword">var</span> differenceSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="comment">//将当前集合转换为数组</span></span><br><span class="line">  <span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line">  <span class="comment">//遍历数组，如果另外一个集合没有该元素，则differenceSet加入该元素。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class="line">      differenceSet.add(values[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> differenceSet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="subset方法"><a href="#subset方法" class="headerlink" title="subset方法"></a>subset方法</h4><p>说明: 判断该集合是否为传入集合的子集。这段代码在我自己写完后与书上一比对，觉得自己超级low。我写的要遍历数组三次，书上的只需要一次，算法复杂度远远低于我的。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断该集合是否为传入集合的子集</span><br><span class="line"> * @param  &#123;Set&#125; otherSet 传入的集合</span><br><span class="line"> * @return &#123;Boolean&#125;      是则返回True</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.subset = <span class="function"><span class="keyword">function</span>(<span class="params">otherSet</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 第一个判定,如果该集合长度大于otherSet的长度</span></span><br><span class="line">  <span class="comment">// 则直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.size() &gt; otherSet.size()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前集合转换为数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">this</span>.values();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!otherSet.has(values[i])) &#123;</span><br><span class="line">        <span class="comment">// 第二个判定。只要有一个元素不在otherSet中</span></span><br><span class="line">        <span class="comment">// 那么则可以直接判定不是子集，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>源代码在此~</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/Set.js" target="_blank" rel="external">集合-源代码</a></p>
</blockquote>
<h2 id="ES6中的集合"><a href="#ES6中的集合" class="headerlink" title="ES6中的集合"></a>ES6中的集合</h2><p>ES6也提供了集合，但之前看ES6的集合操作一直迷迷糊糊的。实现一遍后再去看，感觉概念清晰了很多。<br>具体的我掌握的不是很好，还在学习中，就不写出来啦~推荐看阮一峰老师的《ECMAScript 6入门》中对ES6 Set的介绍。</p>
<blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/set-map#WeakSet" target="_blank" rel="external">《ECMAScript 6入门》– Set和Map数据结构</a></p>
</blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>到了这儿，已经掌握了一些基本的数据结构。剩下的都是难啃的骨头了(对我而言)。</p>
<p>字典的散列表、图、树、排序算法。算是四大金刚，所以近期关于数据结构与算法系列的文章，可能会更新的很慢。对我来说，也算是一个坎。希望这个寒假，能跨过这个坎。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(4)——学习JavaScript数据结构与算法：链表" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/15/寒假前端学习/寒假前端学习(4)——学习JavaScript数据结构与算法：链表/" class="article-date">
  	<time datetime="2016-01-15T02:09:55.000Z" itemprop="datePublished">2016-01-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/15/寒假前端学习/寒假前端学习(4)——学习JavaScript数据结构与算法：链表/">寒假前端学习(4)——学习JavaScript数据结构与算法（二）：链表</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本系列的第一篇文章: <a href="http://t.cn/R4Ybrs0" target="_blank" rel="external">学习JavaScript数据结构与算法（一）：栈与队列</a><br>第二篇文章：<a href="http://t.cn/R4W3y3X" target="_blank" rel="external">学习JavaScript数据结构与算法（二）：链表</a><br>第三篇文章: <a href="http://t.cn/R4jLf0o" target="_blank" rel="external">学习JavaScript数据结构与算法（三）：集合</a><br>第四篇文章: <a href="http://t.cn/R4QbVOg" target="_blank" rel="external">学习JavaScript数据结构与算法（四）：二叉搜索树</a></p>
</blockquote>
<h2 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h2><p>链表是一种常见的数据结构，也属于线性表，但不会按线性的顺序来储存数据。而是在每一个节点中，储存了下一个节点的指针。可以看图理解。(有C语言基础的可能比较好理解)。<br>使用链表结构可以克服数组需要预先知道数据大小的缺点(C语言的数组需要预先定义长度)，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。</p>
<p>接下来就是介绍两种常见的链表: 单向链表，双向链表在JavaScript中的实现。</p>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>链表中最简单的形式就是单向链表，链表中的节点都包含两个部分，第一部分储存着自身信息，第二部分则储存有指向下一节点的指针。最后一个节点则指向<code>NULL</code>，如图所示:<br><img src="http://7xoxxe.com1.z0.glb.clouddn.com/link1.png" alt="单向链表图示2"></p>
<h3 id="JavaScipt中单向链表的实现"><a href="#JavaScipt中单向链表的实现" class="headerlink" title="JavaScipt中单向链表的实现"></a>JavaScipt中单向链表的实现</h3><p>首先，创建一个构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 单向链表构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 单向链表中节点的构造函数</span><br><span class="line">   * @param &#123;Any&#125; element 要传入链表的节点</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="comment">//下个节点的地址</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//单向链表的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//单向链表的头结点，初始化为NULL</span></span><br><span class="line">  <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，单向链表构造函数比栈与队列要复杂许多。</p>
<p>单向链表需要有如下的方法:</p>
<ul>
<li>append(element): 添加元素到链表尾部</li>
<li>insert(position,element): 向单向链表中某个位置插入元素</li>
<li>indexOf(element): 寻找某个元素在单向链表中的位置</li>
<li>remove(element): 移除给定的元素</li>
<li>removeAt(position): 移除单向链表中某个位置的元素</li>
<li>getHead(): 获取单向链表的头部</li>
<li>isAmpty(): 检查单向链表是否为空，为空则返回true</li>
<li>toString(): 将链表所有内容以字符串输出</li>
<li>size(): 返回单向链表长度</li>
</ul>
<h4 id="append方法"><a href="#append方法" class="headerlink" title="append方法:"></a>append方法:</h4><p>说明: 向单向链表尾部添加元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 向单向链表尾部添加元素</span><br><span class="line"> * @param  &#123;Any&#125; element 要加入链表的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">  <span class="keyword">var</span> current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当前项等于链表头部元素.</span></span><br><span class="line">    <span class="comment">// while循环到最后一个，从而将该节点加入链表尾部。</span></span><br><span class="line">    current = head;</span><br><span class="line">    <span class="comment">// 当next为null时，判定为false。退出循环。</span></span><br><span class="line">    <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.next = node;</span><br><span class="line">  &#125;</span><br><span class="line">  length++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="insert方法"><a href="#insert方法" class="headerlink" title="insert方法:"></a>insert方法:</h4><p>说明: 向单向链表中某个位置插入元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 向单向链表中插入某个元素</span><br><span class="line"> * @param  &#123;Number&#125; position 要插入的位置</span><br><span class="line"> * @param  &#123;Any&#125; element  要插入的元素</span><br><span class="line"> * @return &#123;Boolean&#125;          插入成功返回true，失败返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">var</span> current = head;</span><br><span class="line">    <span class="keyword">var</span> previous;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">      node.next = current;</span><br><span class="line">      head = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span><br><span class="line">        <span class="attr">previous</span> = <span class="string">current;</span></span><br><span class="line">        <span class="attr">current</span> = <span class="string">current.next;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="attr">previous.next</span> = <span class="string">node;</span></span><br><span class="line">      <span class="attr">node.next</span> = <span class="string">current;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">length</span>++;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">true</span>;</span><br><span class="line">  &#125; <span class="attr">else</span> &#123;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="indexOf方法"><a href="#indexOf方法" class="headerlink" title="indexOf方法:"></a>indexOf方法:</h4><p>说明：寻找某个元素在单向链表中的位置。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 寻找某个元素在单向链表中的位置</span><br><span class="line"> * @param  &#123;Any&#125; element 要寻找的元素</span><br><span class="line"> * @return &#123;Number&#125;         返回值&gt;=0则代表找到相应位置</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = head;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element === current.element) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法:"></a>remove方法:</h4><p>说明: 移除给定的元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 移除给定的元素</span><br><span class="line"> * @param  &#123;Any&#125; element 要移除的元素</span><br><span class="line"> * @return &#123;Number&#125;         返回值&gt;=0表示移除成功</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.remove = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> index = <span class="keyword">this</span>.indexOf(element);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.removeAt(index);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="removeAt方法"><a href="#removeAt方法" class="headerlink" title="removeAt方法:"></a>removeAt方法:</h4><p>说明:移除单向链表中某个位置的元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 移除单向链表中某一个元素</span><br><span class="line"> * @param  &#123;Number&#125; position 要移除元素的位置</span><br><span class="line"> * @return &#123;Any&#125;          移除成功返回被移除的元素，不成功则返回NULL</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">    <span class="keyword">var</span> current = head;</span><br><span class="line">    <span class="keyword">var</span> previous;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 因为之前head指向第一个元素，现在把head修改为指向第二个元素。</span></span><br><span class="line">      <span class="comment">// 核心概念在于链表前后全靠指针链接，而非数组一般。</span></span><br><span class="line">      <span class="comment">// 所以只需要改变head的元素。</span></span><br><span class="line">      head = current.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span><br><span class="line">        // <span class="attr">previous</span>指要操作元素位置之前的那个元素，<span class="attr">current</span>表示之后的那个元素。</span><br><span class="line">        <span class="attr">previous</span> = <span class="string">current;</span></span><br><span class="line">        <span class="attr">current</span> = <span class="string">current.next;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="attr">previous.next</span> = <span class="string">current.next;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">length--</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attr">return</span> <span class="attr">current.element</span>;</span><br><span class="line">  &#125; <span class="attr">else</span> &#123;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="getHead方法"><a href="#getHead方法" class="headerlink" title="getHead方法:"></a>getHead方法:</h4><p>说明:获取单向链表的头部。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取单向链表的头部</span><br><span class="line"> * @return &#123;Any&#125; 单向链表的头部</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.getHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="isAmpty、toString、size方法"><a href="#isAmpty、toString、size方法" class="headerlink" title="isAmpty、toString、size方法"></a>isAmpty、toString、size方法</h4><p>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断单向链表是否为空</span><br><span class="line"> * @return &#123;Boolean&#125; 为空则返回true，不为空则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.isAmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length === <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 将链表所有内容以字符串输出</span><br><span class="line"> * @return &#123;String&#125; 要输出的字符串</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = head;</span><br><span class="line">  <span class="keyword">var</span> string = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    string += current.element;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回单向链表长度</span><br><span class="line"> * @return &#123;Number&#125; 单向链表的长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>以上的就是单向链表在JavaScript中的实现，有兴趣的同学可以自己下载源代码查看。</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/LinkedList.js" target="_blank" rel="external">单向链表-源代码</a></p>
</blockquote>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表与单向链表很是相像。在单向链表中，只有指向下一个节点的链接。但在双向链表中，<strong>还有指向上一个节点的链接，是双向的。</strong><br>如图所示: <img src="http://7xoxxe.com1.z0.glb.clouddn.com/dlink.png" alt="双向链表图示"></p>
<h3 id="JavaScipt中双向链表的实现"><a href="#JavaScipt中双向链表的实现" class="headerlink" title="JavaScipt中双向链表的实现"></a>JavaScipt中双向链表的实现</h3><p>首先，依然是构造函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 双向链表的构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DoublyLinkedList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * 双向链表中节点的构造函数</span><br><span class="line">   * @param &#123;Any&#125; element 要传入链表的元素</span><br><span class="line">   */</span></span><br><span class="line">  <span class="keyword">var</span> Node = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">    <span class="keyword">this</span>.prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//双向链表的长度</span></span><br><span class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//双向链表的头结点，初始化为NULL</span></span><br><span class="line">  <span class="keyword">var</span> head = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//双向链表的尾结点，初始化为NULL</span></span><br><span class="line">  <span class="keyword">var</span> tail = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双向链表需要有如下的方法:</p>
<ul>
<li>append(element): 添加元素到双向链表尾部</li>
<li>insert(position,element): 向双向链表中某个位置插入元素</li>
<li>removeAt(position): 移除双向链表中某个位置的元素</li>
<li>showHead(): 获取双向链表的头部</li>
<li>showLength(): 获取双向链表长度</li>
<li>showTail(): 获取双向链表尾部</li>
</ul>
<h4 id="append方法-1"><a href="#append方法-1" class="headerlink" title="append方法:"></a>append方法:</h4><p>说明: 添加元素到双向链表尾部<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 向链表尾部添加元素</span><br><span class="line"> * @param  &#123;Any&#125; element 要加入链表的节点</span><br><span class="line"> * @return &#123;Any&#125;         加入链表的节点</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.append = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">    head = node;</span><br><span class="line">    tail = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> previous;</span><br><span class="line">    <span class="keyword">var</span> current = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current.next) &#123;</span><br><span class="line">      current = current.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current.next = node;</span><br><span class="line">    node.prev = current;</span><br><span class="line">    tail = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  length++;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="insert方法-1"><a href="#insert方法-1" class="headerlink" title="insert方法:"></a>insert方法:</h4><p>说明: 向双向链表中某个位置插入元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 向链表中插入某个元素</span><br><span class="line"> * @param  &#123;Number&#125; position 要插入的位置</span><br><span class="line"> * @return &#123;Boolean&#125;         插入成功返回true，失败返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.insert = <span class="function"><span class="keyword">function</span>(<span class="params">position, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &gt;= <span class="number">0</span> &amp;&amp; position &lt;= length) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = <span class="keyword">new</span> Node(element);</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> previous;</span><br><span class="line">    <span class="keyword">var</span> current = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (head === <span class="literal">null</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        tail = node;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current.prev = node;</span><br><span class="line">        node.next = current;</span><br><span class="line">        head = node;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length) &#123;</span><br><span class="line"></span><br><span class="line">      current = tail;</span><br><span class="line">      current.next = node;</span><br><span class="line">      node.prev = current;</span><br><span class="line">      tail = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span><br><span class="line">        <span class="attr">previous</span> = <span class="string">current;</span></span><br><span class="line">        <span class="attr">current</span> = <span class="string">current.next;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="attr">previous.next</span> = <span class="string">node;</span></span><br><span class="line">      <span class="attr">node.prev</span> = <span class="string">previous;</span></span><br><span class="line">      <span class="attr">current.prev</span> = <span class="string">node;</span></span><br><span class="line">      <span class="attr">node.next</span> = <span class="string">current;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">length</span>++;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">true</span>;</span><br><span class="line">  &#125; <span class="attr">else</span> &#123;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="removeAt方法-1"><a href="#removeAt方法-1" class="headerlink" title="removeAt方法:"></a>removeAt方法:</h4><p>说明:移除双向链表中某个位置的元素。<br>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 移除链表中某一个元素</span><br><span class="line"> * @param  &#123;Number&#125; position 要移除元素的位置</span><br><span class="line"> * @return &#123;Any&#125;             移除成功返回被移除的元素，不成功则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.removeAt = <span class="function"><span class="keyword">function</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (position &gt; <span class="number">-1</span> &amp;&amp; position &lt; length) &#123;</span><br><span class="line">    <span class="keyword">var</span> current = head;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> previous;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">      head = current.next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">        tail = <span class="literal">null</span>;</span><br><span class="line">        head.prev = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === length - <span class="number">1</span>) &#123;</span><br><span class="line">      current = tail;</span><br><span class="line">      tail = current.prev;</span><br><span class="line">      tail.next = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (index++ <span class="xml"><span class="tag">&lt; <span class="attr">position</span>) &#123;</span><br><span class="line">        <span class="attr">previous</span> = <span class="string">current.prev;</span></span><br><span class="line">        <span class="attr">current</span> = <span class="string">current.next;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="attr">previous.next</span> = <span class="string">current.next;</span></span><br><span class="line">      <span class="attr">current.next.prev</span> = <span class="string">previous;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attr">length--</span>;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">current.element</span>;</span><br><span class="line">  &#125; <span class="attr">else</span> &#123;</span><br><span class="line">    <span class="attr">return</span> <span class="attr">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="showHead、showLength、showTail方法"><a href="#showHead、showLength、showTail方法" class="headerlink" title="showHead、showLength、showTail方法"></a>showHead、showLength、showTail方法</h4><p>实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取链表的头部</span><br><span class="line"> * @return &#123;Any&#125; 链表的头部</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.showHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取链表长度</span><br><span class="line"> * @return &#123;Number&#125; 链表长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.showLength = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取链表尾部</span><br><span class="line"> * @return &#123;Any&#125; 链表尾部</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.showTail = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><p>源代码在此~</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/DoublyLinkedList.js" target="_blank" rel="external">双向链表-源代码</a></p>
</blockquote>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>链表这一节，基本全部都是先按需求写代码，写完后再和书上对比。发现简直被瞬间秒成渣。自己写的很多暗坑，逻辑也很混乱。看来还是太年轻了。</p>
<p>有兴趣的同学，也可以自己试试只看要求先写代码，写完后再与书上比对，就知道自己的不足了。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-寒假前端学习/寒假前端学习(3)——学习JavaScript数据结构与算法：栈与队列" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/01/14/寒假前端学习/寒假前端学习(3)——学习JavaScript数据结构与算法：栈与队列/" class="article-date">
  	<time datetime="2016-01-14T03:09:55.000Z" itemprop="datePublished">2016-01-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/14/寒假前端学习/寒假前端学习(3)——学习JavaScript数据结构与算法：栈与队列/">寒假前端学习(3)——学习JavaScript数据结构与算法（一）：栈与队列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本系列的第一篇文章: <a href="http://t.cn/R4Ybrs0" target="_blank" rel="external">学习JavaScript数据结构与算法（一）：栈与队列</a><br>第二篇文章：<a href="http://t.cn/R4W3y3X" target="_blank" rel="external">学习JavaScript数据结构与算法（二）：链表</a><br>第三篇文章: <a href="http://t.cn/R4jLf0o" target="_blank" rel="external">学习JavaScript数据结构与算法（三）：集合</a><br>第四篇文章: <a href="http://t.cn/R4QbVOg" target="_blank" rel="external">学习JavaScript数据结构与算法（四）：二叉搜索树</a></p>
</blockquote>
<h2 id="学习起因"><a href="#学习起因" class="headerlink" title="学习起因"></a>学习起因</h2><p>曾经有一次在逛V2EX时，碰到这么一个帖子。</p>
<blockquote>
<p><a href="https://www.v2ex.com/t/247874" target="_blank" rel="external">数学完全还给老师了，想学回一些基础数学，大概是高中程度的，有什么书籍推荐？</a></p>
</blockquote>
<p>发帖的楼主大学没有高数课程，出去工作时一直在从事前端的工作。感觉到数学知识的匮乏，所以想补一补数学。</p>
<p>看了看帖子，感觉和我很像，因为我的专业是不开高数的，我学的也是前端。也同样感觉到了数学知识匮乏所带来的困顿。同时因为自己的数学思维实在是不怎么好，所以决定努力补习数学与计算机基础知识。</p>
<p>当时也有人说:”前端需要什么数据结构与算法”，但是对于这个事情我有自己的看法。</p>
<blockquote>
<p>我并不认为前端不需要算法之类的知识，在我看来前端具备坚实的计算机基础，对自身发展是极其有利的。我想做程序员。而不是一辈子的初级前端和码农。</p>
</blockquote>
<p>也算是给自己的勉励吧。毕竟基础决定上限，再加上自己对计算机真的很感兴趣，所以学起来就算很累，但也是很幸福的。于是去网上选购了《学习JavaScript数据结构与算法》这本书，配合着去图书馆借阅的《大话数据结构》，开始了数据结构与算法的初步学习。</p>
<p><img src="http://7xoxxe.com1.z0.glb.clouddn.com/ds.png" alt="选用的书籍"></p>
<p>这本书讲的内容很是不错，清晰易懂。同时用JavaScipt语言实现，学起来的难度低。值得一看呢。</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>书中前两章是对JavaScipt基础与数组常用操作的讲解，如果不清楚的话,推荐去看看下面这篇博客。</p>
<blockquote>
<p><a href="http://www.cnblogs.com/zhangzt/archive/2011/04/01/2002213.html" target="_blank" rel="external">JavaScipt之数组操作</a></p>
</blockquote>
<p>接下来就是数据结构的第一部分，栈。</p>
<p>栈是一种遵从后进先出原则(LIFO,全称为Last In First Out)的有序集合。栈顶永远是最新的元素。</p>
<p>举个例子就是:栈就像放在箱子里的一叠书 你要拿下面的书先要把上面的书拿开。(当然，你不能先拿下面的书。)</p>
<p>看图示也可明白。</p>
<p><img src="http://7xoxxe.com1.z0.glb.clouddn.com/stack.jpg" alt="栈的图示"></p>
<h3 id="JavaScipt中栈的实现"><a href="#JavaScipt中栈的实现" class="headerlink" title="JavaScipt中栈的实现"></a>JavaScipt中栈的实现</h3><p>首先，创建一个构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 栈的构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用数组来模拟栈</span></span><br><span class="line">  <span class="keyword">var</span> item = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栈需要有如下的方法:</p>
<ul>
<li>push(element(s)): 添加几个元素到栈顶</li>
<li>pop(): 移除并返回栈顶元素</li>
<li>peek(): 返回栈顶元素</li>
<li>isAmpty: 检查栈是否为空，为空则返回true</li>
<li>clear: 移除栈中所有元素</li>
<li>size: 返回栈中元素个数。</li>
<li>print: 以字符串显示栈中所有内容</li>
</ul>
<h4 id="push方法的实现"><a href="#push方法的实现" class="headerlink" title="push方法的实现"></a>push方法的实现</h4><p>说明: 需要往栈中添加新元素，元素位置在队列的末尾。也就是说，我们可以用数组的push方法来模拟实现。</p>
<p>实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将元素送入栈，放置于数组的最后一位</span><br><span class="line"> * @param  &#123;Any&#125; element 接受的元素，不限制类型</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  items.push(element);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="pop方法的实现"><a href="#pop方法的实现" class="headerlink" title="pop方法的实现"></a>pop方法的实现</h4><p>说明: 需要把栈顶元素弹出，同时返回被弹出的值。可以用数组的pop方法来模拟实现。</p>
<p>实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 弹出栈顶元素</span><br><span class="line"> * @return &#123;Any&#125; 返回被弹出的值</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.pop();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="peek方法的实现"><a href="#peek方法的实现" class="headerlink" title="peek方法的实现"></a>peek方法的实现</h4><p>说明: 查看栈顶元素，可以用数组长度来实现。</p>
<p>实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 查看栈顶元素</span><br><span class="line"> * @return &#123;Any&#125; 返回栈顶元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其余方法的实现"><a href="#其余方法的实现" class="headerlink" title="其余方法的实现"></a>其余方法的实现</h4><p>说明: 前三个是栈方法的核心，其余方法则在此一次性列出。因为下文要讲的队列，会与这部分有很大重合。</p>
<p>实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 确定栈是否为空</span><br><span class="line"> * @return &#123;Boolean&#125; 若栈为空则返回true,不为空则返回false</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.isAmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.length === <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 清空栈中所有内容</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 返回栈的长度</span><br><span class="line"> * @return &#123;Number&#125; 栈的长度</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 以字符串显示栈中所有内容</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>栈的实际应用比较多，书中有个十进制转二进制的函数。(不懂二进制怎么算的话可以百度)下面是函数的源代码。</p>
<p>原理就是输入要转换的数字，不断的除以二并取整。并且最后运用while循环，将栈中所有数字拼接成字符串输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将10进制数字转为2进制数字</span><br><span class="line"> * @param  &#123;Number&#125; decNumber 要转换的10进制数字</span><br><span class="line"> * @return &#123;Number&#125;           转换后的2进制数字</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divideBy2</span>(<span class="params">decNumber</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> remStack = <span class="keyword">new</span> Stack(),</span><br><span class="line">    rem,</span><br><span class="line">    binaryString = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (decNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(decNumber % <span class="number">2</span>);</span><br><span class="line">    remStack.push(rem);</span><br><span class="line">    decNumber = <span class="built_in">Math</span>.floor(decNumber / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!remStack.isAmpty()) &#123;</span><br><span class="line">    binaryString += remStack.pop().toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> binaryString;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到此而言，栈的学习就告一段落了。因为源代码中注释较多，所以这儿就不贴出源代码的内容了。有兴趣的可以自己下载查看。</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/Stack.js" target="_blank" rel="external">栈-源代码</a></p>
</blockquote>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列与栈是很相像的数据结构，不同之处在于队列是是先进先出(FIFO:First In First Out)的。</p>
<p>举个例子: 火车站排队买票，先到的先买。(插队的不算)，是不是很好理解了~</p>
<h3 id="JavaScipt中队列的实现"><a href="#JavaScipt中队列的实现" class="headerlink" title="JavaScipt中队列的实现"></a>JavaScipt中队列的实现</h3><p>队列的实现和栈很像。首先依然是构造函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 队列构造函数</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列需要有如下的方法:</p>
<ul>
<li>enqueue(element(s)): 向队列尾部添加几个项</li>
<li>dequeue(): 移除队列的第一项(也就是排在最前面的项)</li>
<li>front(): 返回队列的第一个元素，也就是最新添加的那个</li>
</ul>
<p>其余方法与队列相同</p>
<h4 id="enqueue方法的实现"><a href="#enqueue方法的实现" class="headerlink" title="enqueue方法的实现"></a>enqueue方法的实现</h4><p>说明: 向队列尾部添加几个项。</p>
<p>实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将元素推入队列尾部</span><br><span class="line"> * @param  &#123;Any&#125; ele 要推入队列的元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  items.push(ele);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dequeue方法的实现"><a href="#dequeue方法的实现" class="headerlink" title="dequeue方法的实现"></a>dequeue方法的实现</h4><p>说明: 移除队列的第一项。</p>
<p>实现: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 将队列中第一个元素弹出</span><br><span class="line"> * @return &#123;Any&#125; 返回被弹出的元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.shift()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="front方法的实现"><a href="#front方法的实现" class="headerlink" title="front方法的实现"></a>front方法的实现</h4><p>说明: 返回队列的第一个元素，也就是最新添加的那个。</p>
<p>实现:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 查看队列的第一个元素</span><br><span class="line"> * @return &#123;Any&#125; 返回队列中第一个元素</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">this</span>.front = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上的三个方法，就是队列这种数据结构的核心方法了。其实很好理解的。</p>
<h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>书上的是个击鼓传花的小游戏。原理就是循环到相应位置时，队列弹出那个元素。最后留下的就是赢家。</p>
<p>源代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 击鼓传花的小游戏</span><br><span class="line"> * @param  &#123;Array&#125;  nameList 参与人员列表</span><br><span class="line"> * @param  &#123;Number&#125; num      在循环中要被弹出的位置</span><br><span class="line"> * @return &#123;String&#125;          返回赢家(也就是最后活下来的那个)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hotPotato</span>(<span class="params">nameList, num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nameList.length; i++) &#123;</span><br><span class="line">    queue.enqueue(nameList[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> eliminated = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      queue.enqueue(queue.dequeue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eliminated = queue.dequeue();</span><br><span class="line">    <span class="built_in">console</span>.log(eliminated + <span class="string">" Get out!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> queue.dequeue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现，有兴趣的同学可以自己下载源代码，试一试。</p>
<blockquote>
<p><a href="https://github.com/Lxxyx/LearnDataStructrue/blob/master/Queue.js" target="_blank" rel="external">队列-源代码</a></p>
</blockquote>
<p>队列的学习到此就告一段落了。下一期将讲述另外一种数据结构: 链表。</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>很多时候看书，直接看算法导论或者一些数据结构的书，都是很迷糊的。后来才发现，看书从自己能看懂的开始，由浅入深才是适合自己的学习方式。</p>
<p>前端路漫漫，且行且歌~</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端/">前端</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Lxxyx
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71744638-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




  </div>
</body>
</html>